<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>MAF : Overview : Computations on whole groups or monoids</title>
<link type="text/css" rel="StyleSheet" href="site.css">
<link rel="Start" type="text/html" href="MAF.html"> 
<link rel="Chapter" type="text/html" href="Preface.html" title="Introduction">
<link rel="Chapter" type="text/html" href="overview.html" title="An overview of MAF">
<link rel="Chapter" type="text/html" href="reference.html" title="MAF Reference">
<link rel="Chapter" type="text/html" href="MAF.html#tutorials" title="Tutorials">
<link rel="Chapter" type="text/html" href="background.html" title="Background material">
<link rel="Chapter" type="text/html" href="MAF.html#appendices" title="Appendices">
<link rel="Copyright" type="text/html" href="copyright.html"> 
<link rel="Contents" type="text/html" href="MAF.html"> 

<link rel="Prev" type="text/html" href="solutions.html" title="Overview: Solutions to the word problem">
<link rel="Next" type="text/html" href="cosets.html" title="Overview : Computations on subgroups">

<script type="text/javascript" language="Javascript" src="site.js">
</script>
</head>
<body onload="OnPageLoad()" onunload="OnPageUnload()">
<a href="MAF.html">MAF</a> : <a href="overview.html">Overview</a> : Computations on whole groups or monoids

<h2>MAF: Computations on whole groups or monoids</h2>
<p>Readers interested in such matters should note that MAF does not deal with semigroups. It is a trivial operation to convert a semigroup into corresponding monoid, and equally trivial to convert the automata MAF produces for such a monoid into automata for the original semigroup. If support for semigroups is desired it will be easy to add.</p>
<p><em>Most of the computations to be described in this section are usually performed by invoking MAF's principal utility:</em> <tt>automata</tt>.</p>
<h3>Presentations, rewriting systems and "input files"</h3>
<p>In order for MAF to be able to perform computations on a group or monoid, it must first be supplied with an appropriate presentation, in the form of a text file containing a <a href="http://www.geom.uiuc.edu/~dfh/gasp.html">standard GASP format</a> rewriting system. A file in this format will generally be called simply an <dfn>input file</dfn> in this document.</p>
<p>Although the MAF user will probably think of an input file as a presentation it is important to remember that there are some differences from a group presentation:</p>
<ol><li>MAF works with monoid presentations. This means that MAF needs to be told, which, if any, of the generators are invertible, and that both the generator and its inverse need to be included in the list of generators when an input file is created from a group presentation. 
<li>The input file must contain, at least implicitly, information which establishes a <a href="Orderings.html#reduction">reduction ordering</a> of all the words in the generators. </ol>
<p>An informal definition of the syntax of input files syntax can be found in <a href="input_files.html">MAF Reference : Input files</a>. The various options for ordering words are discussed in <a href="word_ordering_methods.html">MAF Reference : Word-ordering methods</a>.</p>
<p><em>Readers who have not already done so, and who have not previously used KBMAG, should refer to <a href="example1.html">MAF Tutorial 1: Processing an input file</a> before continuing.</em></p>

<h3>Searching for a solution to the word problem</h3>
<p>Once an input file has been created, one may need to decide what kind of a solution to the word problem MAF should look for. The good news is that in many cases this is unnecessary. However, it is important that the user should be aware of the issues, because otherwise MAF may run in an inefficient manner. The various possibilities are discussed more fully in <a href="solutions.html">Overview: Solutions to the word problem</a>. <tt>automata</tt> will attempt to construct either a <a href="solutions.html#confluent">finite confluent rewriting system</a>, or an <a href="solutions.html#automatic">automatic structure</a> (or very likely both). In either case the computation usually uses the Knuth-Bendix procedure. An alternative, for input files describing a finite group, is to attempt to use <a href="#gptcenum">coset enumeration</a> to find the <a href="solutions.html#coset">coset table</a> of the group.</p>
<h4>Bad news</h4>
<p>Not all input files have a finite confluent rewriting system, and many infinite groups and monoids may not have a finite confluent rewriting system for any choice of generating set and reduction ordering. The existence of a finite confluent rewriting system for any particular choice of generating set and word-ordering does not guarantee its existence for any other choice.</p>
<p>Not all groups have automatic structures. There are infinite groups, with a solvable word problem, for which it is possible to show that no such structure can exist. If a group does have an automatic structure then the group is called an "automatic group". In principle, the existence of an automatic structure for some choice of generating set <em>does</em> guarantee the existence of one for any other finite generating set; this is why it is meaningful to talk of a group's being automatic. An algorithm exists for constructing an automatic structure on an arbitrary finite set of generators given any particular automatic structure. MAF is only able to <em>find</em> automatic structures that are natural for the chosen generating set and word-ordering: ones in which the accepted word for each element is the least word in the word-ordering that is equal to it as a group element. However, if you have succeeded in computing an automatic structure using some generating set, MAF is able to compute a word acceptor for any other genererating set using the utility <a href="gp_usage.html#gpxlatwa"><tt>gpxlatwa</tt></a>. 
</p>
<p>It will be useful, informally, to speak of an input file as being automatic or confluent, where by this the terms are understood to mean, "MAF can compute an automatic structure from the input file" and "MAF can compute a finite confluent rewriting system from the input file". This makes it easier to state an important fact: an input file can be either, neither, or both of these. MAF's ability to find either type of structure for a group is heavily dependent on the choice of presentation and word-ordering (a first hint of this can be found by referring to <a href="example2.html">MAF Tutorials: 2 - Choosing generators</a>). So, given a presentation for an unknown group, one is immediately faced with the dilemma of which kind of structure to look for. This dilemma does not as occur for monoids, since MAF cannot construct automatic structures for them.</p>

<h4>MAF searches for automatic structures <em>and</em> confluent rewriting systems</h4>
<p>A major difference between MAF and KBMAG from the point of view of a user hoping to find a solution to the word problem for a particular group, is that with KBMAG one has to decide in advance, whether to look for an automatic structure, or for a confluent rewriting system. In MAF the situation is different: MAF's default behaviour, usually, is to look for both at the same time. This is not always the advantage it might seem to be - it might sometimes be better to run two copies of <tt>automata</tt> independently, one looking for an automatic structure, the other for a confluent rewriting system. Also, in some cases, it will quickly become apparent to the user that there is little or no hope of finding an automatic structure. In such cases it is usually much better to interrupt <tt>automata</tt>, and to start it again with an option which tells it only to look for a confluent rewriting system.</p>
<p>MAF has no means of knowing in advance whether its computations will succeed (no such means can exist), and it will run for ever until they do, unless interrupted, or it gives up due to limits placed on it being exceeded, or insufficient resources are available for it to continue.</p>
<h4>Forcing MAF to search just for an automatic structure or just for a confluent rewriting system</h4>
<p>The user can supply various command line options, which will control what automata MAF searches for, and when they are searched for. These may be termed <dfn>goal setting options.</dfn> We shall introduce the most important of these now. Refer to <a href="automata_usage.html"> MAF Reference (Usage): <tt>automata</tt></a> for more complete information on all the many command line options accepted by <tt>automata</tt>.</p>

<h5>To search only for a confluent rewriting system</h5>
<p>There are two command line options for doing this: <kbd>-no_wd</kbd> and <kbd>-confluent</kbd>. The options only differ in what happens when MAF does succeed in finding a confluent rewriting system. With the first option, this is the only structure that MAF will compute and output. With the second option, MAF will then attempt to compute an automatic structure as well, using a word-acceptor computed from the rewriting system as the basis of the structure. Both these options may substantially speed up processing, and do usually do so if the input file presents a finite group. The <kbd>-confluent</kbd> option is on by default if the input file uses a word-ordering for which the construction of automatic structures is difficult. For large finite groups automatic structures can require a lot of computation, and the confluent rewriting system will usually be more useful in practice, and so  the <kbd>-no_wd</kbd> option is often used with such groups.</p>
<h5>To search only for an automatic structure</h5>
<p>The <kbd>-no_kb</kbd> option tells MAF not to use the Knuth-Bendix procedure, and instead to attempt to construct an automatic structure immediately, using only the equations contained in the input file, and any others that are readily deducible from them. For infinite automatic groups this option often produces the fastest results, even for some groups for which the construction of the automatic structure is quite difficult. However, it can happen that MAF has great difficulty in building trial automatic structures. In such cases it may be best to run <tt>automata</tt> without this option, to allow more word-differences to be discovered first (though for the most difficult automatic groups it is often the case that there is almost no hope of running Knuth-Bendix for long enough to avoid this difficulty - it is very difficult to know when all the word-differences have been discovered). The <kbd>-no_kb</kbd> option is disastrous if the presentation is actually a difficult presentation of a finite group. MAF will usually eventually be able to discover this, but it will take much longer than it would have done had the Knuth-Bendix procedure been used. If a group is finite MAF will insist on finding the confluent rewriting system that certainly exists before it computes the automatic structure.</p>
<h5>To search for an automatic structure when this is not the default behaviour</h5>
<p>MAF's default behaviour is to search for an automatic structure only when an input file for a group uses a geodesic word-ordering (i.e. a word-ordering where a word is always greater than any shorter word). To make MAF  search for an automatic structure for a word-ordering such as <tt>wtlex</tt> then one can use either of two options: <kbd>-wd</kbd> or <kbd>-force_differences</kbd>. The behaviour of the latter option is described in the next section. The <kbd>-wd</kbd> option will cause MAF to search for word-differences  with its default strategy, in which equations with word-differences are favoured only until there are 5000 word-differences or so.</p>

<h5>Using a preliminary run of <tt>automata</tt> to decide upon the best strategy</h5>
<p>The <kbd>-force_differences</kbd> command line option will ensure that MAF computes word-differences if it is possible to do so, and will not stop favouring equations that contain new word-differences if the number of word-differences is high. One can run <tt>automata</tt> like this for a minute or two to help decide on the best strategy. If the number of word differences increases rapidly, and soon exceeds 5000, then there is little or no hope that MAF will be able to compute an automatic structure. In such cases it is best to stop <tt>automata</tt> and to restart it with the <kbd>-confluent</kbd> or <kbd>-no_wd</kbd> options. If, on the other hand, the number of word differences has stopped increasing rapidly by this time, then there is a good chance that the <kbd>-no_kb</kbd> option will give the fastest results. Start a second copy of <tt>automata</tt>, specifying the <kbd>-no_kb</kbd> option, this time leaving the first copy running, and wait until one of them succeeds. If memory becomes short then stop whichever seems to be making less progress.</p>
<h4>A note about word-acceptors</h4>
<p>It is perfectly possible for an input file to have a provably correct word-acceptor which does not form part of an automatic structure. This will happen, for example, whenever there is a finite confluent rewriting system for the input file, but the number of word-differences is not finite.  It may also happen that while the minimal confluent rewriting system is not finite, there are only a finite number of word-differences for it, so that the equations that appear in it can be recognised by an automaton. In such cases one can construct a word-acceptor, even if it is not possible to construct the general multiplier because that requires an infinite number of word-differences. This situation does sometimes arise in practice. MAF can find such word-acceptors but cannot prove them correct.
</p>
<p>MAF prefers, whenever possible, to compute the word-acceptor for an input file from a confluent rewriting system, rather than from a word-difference machine. It is worth having a word-acceptor even when a confluent rewriting system exists, because although both structures can be used to enumerate the reduced word for each element of the group, the former will usually have many fewer states, and use much less memory. For largish finite groups it is often very difficult, if possible at all, to construct a word-acceptor from the word-difference machine, because there are too many word-differences, whereas the computation of the word-acceptor from a confluent rewriting system is very rapid. Usually, though not always, MAF refrains from trying to build an automatic structure prior to a rewriting system becoming confluent, in the case that it will do so, because such groups usually have many word-differences.</p>


<h3>The <kbd>-strategy <i>string</i></kbd> option</h3>
<p>MAF has a very large number of command line options that modify the behaviour of its Knuth-Bendix implementation. These are all documented in <a href="automata_usage.html">Usage: <tt>automata</tt></a>. It is quite difficult to remember how to use all of these various options, so to make life simpler the <kbd>-strategy <i>string</i></kbd> option is provided. This can select one from a range predefined strategies for MAF to follow, and also apply modifications to the chosen strategy. One should do this only if the strategy MAF selects when no specific command line options are given does not seem to work well: some of the strategy options have very bad behaviour with many input files, whereas the automatically chosen strategy MAF will usually work reasonably well, even if it is not necessarily the fastest possible for that particular input file. The various strategies, and the combination of other options that they select are described in detail in <a href="automata_usage.html#strategy">Usage: <tt>automata</tt></a>, but the most important of the strategies are introduced here:</p>
<p>First come three strategies that are not normally specified explicitly, but which are nevertheless important; they select combinations of options that MAF commonly uses in particular scenarios:</p>
<ul>
<li><kbd>-strategy short</kbd> selects the strategy that is usually followed when MAF is looking for a confluent rewriting system and the word-ordering is geodesic.</li>
<li><kbd>-strategy wreath</kbd> selects the strategy that is usually followed when MAF is looking for a confluent rewriting system and the word-ordering is a wreath product ordering, or close to such an ordering.</li>
<li><kbd>-strategy sparse</kbd> selects the strategy that is usually followed when MAF is looking for a shortlex automatic structure.</li>
</ul>
<p>Note that MAF does not actually select any of these options as its "default strategy", because the  "strategy" option does not actually exist internally, and nor do these options.  However, if no specific command line options are chosen, the internal options that MAF really does use in those scenarios would be set to the same values, or at least very similar ones, as these specific strategy options select. The reason why you might want to specify one of these options specifically is that you can use <a href="automata_usage.html#modifier">"strategy modifiers"</a> as a way to investigate whether a minor modification to the default strategy might work better for a particular input file.</p>
<p>Next we mention some strategy options that may sometimes be useful:</p>
<ul><li><p><kbd>-strategy long</kbd> and <kbd>-strategy era</kbd> are important strategies, because one of them may be the only strategy that works well with some input files. Unfortunately MAF is not able to determine for itself when an input file is going to have this unfortunate property, and neither strategy works well the majority of the time, so MAF never works like this by default. If an input file does work well with either of these strategies it is rather likely that KBMAG will process the file as it stands more efficiently than MAF. It is also likely that MAF will be able to process the file much faster than that, and using a default strategy, if the word-ordering method is changed to <code>"recursive"</code> or a similar wreath product ordering. An input file has a good chance of running more quickly with one or other of these strategies if most of the following conditions apply:</p>
<ol><li>Some of the equations in the input file are much longer than others. (Only equations where the total length is more than 4 count here - all equations of length 4 and below are ignored when MAF is trying to decide on a strategy for processing the file).
<li>There are many overlaps involving only short equations.
<li>There are "hidden" short equations, in other words, equations involving only short words that are not obvious consequences of the axioms in the input file, and which can only be deduced from much longer equations.
<li>The input file uses a geodesic word-ordering such as <code>"shortlex"</code>.
</ol>
<li><p><kbd>-strategy quick</kbd> and <kbd>-strategy easy</kbd> turn off some of the additional processing MAF normally performs. As a result some input files will be processed more quickly if one of these two options is used. On the other hand, for some input files these strategies will take much longer than the default strategy, and it is impossible to know for sure which strategy without trying all of them.</p>
</ul>
<h3>Using the progress messages to decide on command line options</h3>
<p>The progress messages usually output by <tt>automata</tt> are not there just to let you know that <tt>automata</tt> has not hung. They contain information which may help you to decide whether the options that
are being used are good.</p>
<ul><li>If too much time seems to be spent processing "special overlaps" or "conjugating" you might want to try the effect of <kbd>-special_overlaps 0</kbd> or <kbd>-conjugation 0</kbd></li>
<li>When processing an input file that uses a wreath product type word-ordering, if too much time seems to be spent "Checking secondaries", and especially if the number of L2/L3 nodes high compared to the number of L1 nodes, then experiment with the <kbd>-weed_secondary</kbd> or <kbd>-secondary 1</kbd> options, or alternatively try the <kbd>-consider_secondary</kbd> option.</li>
</ul>
<h3><a name="gptcenum"></a><tt>gptcenum</tt>: an alternative to <tt>automata</tt></h3>
<p>For finite groups, but not monoids, there is a third possibility for finding a solution to the word problem: instead of using the Knuth-Bendix procedure one can use coset enumeration. If it is possible to enumerate the cosets of the trivial group, then the standardised coset table provides an effective solution to the word problem. On average, and when it works well, computing a coset table using coset enumeration is significantly faster than computing a confluent rewriting system using the Knuth-Bendix procedure, and the coset table may well require less memory than a  confluent rewriting system and index automaton. More information about MAF's coset enumerator <tt>gptcenum</tt> can be found in the relevant section of <a href="gp_usage.html#gptcenum">MAF Reference: RWS Utilities</a>.</p>
<p>For difficult presentations, <tt>automata</tt> is very often far superior in performance, both in execution time, and the amount of memory required. On the other hand, for presentations of very large finite objects with very large confluent rewriting systems <tt>gptcenum</tt> is likely to be much better than <tt>automata</tt>. It is certainly worth experimenting with both programs.
</p>

<h3>Axiom checking. An important difference from KBMAG</h3>
<p>As usually implemented by MAF the algorithm used to construct an automatic structure is theoretically incomplete. When MAF creates an automatic structure for a group it checks that it defines a closed multiplication on the language of the word-acceptor, but it does not check that the multiplication is associative, nor that it actually satisfies the group axioms. In theory MAF should perform some checks to ensure the proposed automatic structure really does define a group multiplication that satisfies the axioms. There is a good reason why it does not do so: the checks frequently take much longer to perform than constructing the automatic structure takes in the first place, and they have <em>never</em> been known to fail (for a group automatic structure). It is possible to make these checks using MAF, either by supplying a command line option when <tt>automata</tt> is invoked, or by running a separate axiom checking program afterwards. The first approach is usually faster, the second approach marginally safer, because more memory will be available if the automatic structure is checked later on by a separate utility.</p>
<p><tt>automata</tt> checks the axioms for the automatic structure if the command line option <kbd>-validate</kbd> is specified. KBMAG users may like to note that this option is automatically supplied if the MAF version of <tt>autgroup</tt> is used  to build an automatic structure instead of <tt>automata</tt>.</p>
<p>The separate utility for checking axioms is called <tt>gpaxioms</tt>; it is described in <a href="gp_usage.html#gpaxioms">Usage information for RWS Utilities</a>.</p>
<p>MAF does check the axioms by default when an automatic structure for a coset system is built, because for coset systems the checks can sometimes fail.</p>

<h3>Examples</h3>
<p>In this section, we mention some of the example input files, all to be found in various subfolders of the <tt>examples</tt> folder. These can usefully be used as test examples, and some of them have been included to demonstrate particular features. </p>

<p>The input files in <tt>trivial</tt> are all presentations of the trivial group. Note, in particular, <tt>degen4a</tt>, <tt>degen4b</tt> and <tt>degen4c</tt>. These are the first three of an infinite sequences of increasingly complicated presentations of the trivial group, due to B.H. Neumann. <tt>automata</tt> will run very quickly on all of these presentations, whereas KBMAG can only do the first two within a reasonable time. The <kbd>-confluent</kbd>, or the <kbd>-nowd</kbd> command line options speed up the calculation considerably in the case of <tt>degen4c</tt>, the primary reason for this being that <tt>automata</tt> computation of word-differences is very time consuming for this presentation. The fastest results for <tt>degen4c</tt> can perhaps be obtained by changing the word-ordering to <code>"recursive"</code> and using the command line options <kbd>-strategy easy -work_order 4</kbd>: when these two options are used the computation takes only one second!. For shortlex <kbd>-strategy easy/i -work_order 6</kbd> is equally fast.</p>

<p>The input files in <tt>automatic</tt> are all for automatic groups. Most of the examples in this folder are of at least moderate difficulty and most run much faster with the <kbd>-nokb</kbd> option than without. Easier examples are to be found in the <tt>hyperbolic</tt> and <tt>coxeter</tt> folders. The most difficult input files  for automatic groups are to be found in the <tt>hard</tt> folder - all those examples require several hours at least.</p>

<p>The example <tt>subgroups/ab2</tt> is the free abelian group on two generators, as is <tt>subgroups/ab2_abAB</tt>. The former, which has <code>generatorOrder := [a,A,b,B]</code> has a finite confluent rewriting system. The latter, which has <code>generatorOrder := [a,b,A,B]</code>, does not. It is almost always best to order the alphabet so that generators and their inverses appear next to one another if they are different.</p>

<p>The <tt>monoids</tt> directory contains a number of monoids. <tt>a4monoid</tt> illustrates what might happen if the <code>inverses</code> field is omitted or not set up. What would be a group of order 12 as a group presentation, becomes an infinite monoid. Several of the examples in this folder are related to the Fibonacci groups. Others are monoid presentations, where generators are not supplied with inverses. Try <tt>f25monoid</tt>, which is the presentation of the Fibonacci group F(2,5), but as a monoid. In fact, the structure is almost identical to the group in this example. The group is cyclic of order 11. The monoid has order 12, the extra element being either the a^11 word (which is not recognised as being equal to <code>IdWord</code>), or <code>IdWord</code> itself. The corresponding semigroup (without the empty <code>IdWord</code>) is isomorphic to the group. <tt>f27monoid</tt> and <tt>f27monoid_shortlex</tt> are both monoid presentations corresponding to the Fibonacci group F(2,7), which has order 29.  As before the monoid has one extra element, which in this case is <i>a^29</i>.  This example is another interesting example of the differences between MAF and KBMAG. KBMAG cannot easily solve this example when shortlex ordering is used, but with MAF it completes in around 5 seconds with the default strategy, and in similar times with some but not all of the other predefined strategies. With this example it is important to allow "special overlap" processing, and to use an "open" strategy that makes use of new equations as soon as possible. Particularly bad results are obtained if <kbd>-strategy era</kbd> is used. For <tt>f27monoid</tt>, which uses <code>"recursive"</code> ordering KBMAG's "maxstoredlen" option is set in the input file. However, the values specified for this option could not possibly work with MAF, because several of the equations in the confluent set exceed the rhs limit. MAF ignores this KBMAG specific option, and, with no limits on equation length, completes almost instantly. Use of the "pool" is crucial to MAF's success for this and most other input files using a wreath product word-ordering.</p>

<p>In the <tt>hyperbolic</tt> folder there are many hyperbolic examples of Von Dyck and triangle groups. All the groups are automatic for any choice of generating set, and it would seem that all of them have finite confluent rewriting systems as well, but not all have them for <tt>"shortlex"</tt> word-ordering. The rule seems to be that all the triangle groups have a finite "shortlex" rewriting system, but the Von Dyck groups only have them when exactly one of the 3 numbers representing the angles of the triangle is even, when the natural 3 generator presentation must be used. All the Von Dyck groups seem to be confluent on a 2 generator presentation using <code>"recursive"</code> ordering. These groups are amongst those discussed in a paper of Le Chenadec from 1986 entitled "Complete group presentations", but the author has not investigated whether the confluent rewriting systems found by MAF are the same as the ones in that paper.</p>

<p>In the <tt>pathological</tt> folder there are a large number of input files that are all for the same group : #8 in the list of presentations of groups of order 3<sup>8</sup> given in "Groups of Deficiency Zero". The files vary only in the word-ordering except that in some cases the relators have been reversed. Some of these can be processed quickly, while others seems to be hopeless cases, and a wide range of unpleasant behaviours can be
observed. For instance with <code>"rt_recursive"</code> ordering the input file can currently be processed fairly quickly with <code>generatorOrder=[A,a,B,b,C,c]</code> but not with <code>generatorOrder=[a,A,b,B,b,c,C]</code>. Many of these files seem extremely sensitive to minor code changes in MAF, or work well only when the command line options are carefully chosen.</p>

<p>In the <tt>recursive</tt> subfolder there are more examples using the <code>"recursive"</code> word-ordering For <tt>nilp2</tt>, <tt>nonhopf</tt>, <tt>heinnilp</tt> and <tt>verifynilp</tt>, a wreath product word-ordering is essential. (These examples also work if they are changed to use an ordering where each generator is at the same level as its inverse. The author has never come across an input file where this is not the case). All these examples are from KBMAG. The last two of these are examples of the use of Knuth-Bendix to prove that a presentation defines a nilpotent group. The <tt>verifynilp</tt> again show the same difference in behaviour from KBMAG as did <tt>f27monoid</tt>example. In KBMAG the <tt>maxstoredlen</tt> parameter (or equivalently the <kbd>-mrl</kbd> option) is used to make <tt>kbprog</tt> complete more quickly for some examples. MAF has to ignore this setting, because in every one of the examples included with KBMAG that use such a setting, the KBMAG value of the setting prevents MAF from ever finding the correct confluent rewriting system, whereas when the setting is ignored MAF very quickly completes successfully! MAF does allow for such a setting however, in case it should ever prove useful: MAF's equivalent of KBMAG's <code>maxstoredlen</code> is <code>maf_maxstoredlen</code>. However, the author has yet to find a single example where the use of this setting is at all beneficial. In most cases it just prevents MAF from ever finding a confluent set.</p>

</body>
</html>
