<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Finite State Automata</title>
<link type="text/css" rel="StyleSheet" href="site.css">
<link type="text/css" rel="StyleSheet" href="site.css">
<link rel="Start" type="text/html" href="MAF.html"> 
<link rel="Chapter" type="text/html" href="Preface.html" title="Introduction">
<link rel="Chapter" type="text/html" href="overview.html" title="An overview of MAF">
<link rel="Chapter" type="text/html" href="reference.html" title="MAF Reference">
<link rel="Chapter" type="text/html" href="MAF.html#tutorials" title="Tutorials">
<link rel="Chapter" type="text/html" href="background.html" title="Background material">
<link rel="Chapter" type="text/html" href="MAF.html#appendices" title="Appendices">
<link rel="Copyright" type="text/html" href="copyright.html"> 
<link rel="Contents" type="text/html" href="MAF.html"> 
<link rel="Next" type="text/html" href="Automatic_structures.html" title="Automatic structures">
<link rel="Prev" type="text/html" href="Rewriting_systems.html" title="Rewriting systems">


<script type="text/javascript" language="Javascript" src="site.js">
</script>
</head>
<body onload="OnPageLoad()" onunload="OnPageUnload()">
<h2><a name="automata"></a><a name="fsa"></a>Finite State Automata</h2>
<p>There are various different ways of defining the concept of a finite state automaton, and various different terminologies associated with them. The definition below is based on that given in <a href="bib.html#sims94">[Sims94]</a>, but has been modified to reflect the implementation of automata in MAF and KBMAG.</p>
<p>A <dfn>finite state automaton</dfn>, or FSA, <i>M</i> is a 5-tuple <span class="nobr">(&Sigma;,&Chi;,&Tau;,&Alpha;,&Omega;)</span> or a 6-tuple  <span class="nobr">(&Sigma;,&Chi;,&Tau;,&Alpha;,&Omega;,&Lambda;)</span> of finite sets with the following properties:</p>
<ol><li>The elements of &Sigma; are called <dfn>states</dfn>, or <dfn>vertices</dfn>.</li>
<li>&Chi; is an alphabet.</li>
<li>&Alpha; and &Omega; are subsets of &Sigma;: The members of &Alpha; are called  <dfn>initial states</dfn> or <dfn>start states</dfn>; The members of &Omega; are called <dfn>accept(ing) states</dfn> or <dfn>final states</dfn>. The latter term is avoided in this document since it might be misleading.</li>
<li>The elements of &Tau; are called <dfn>transitions</dfn> or <dfn>edges</dfn>, and are all triples of the form (&sigma;<sub>1</sub>,&chi;,&sigma;<sub>2</sub>); where &sigma;<sub>1</sub>,&sigma;<sub>2</sub> &isin; &Sigma;, and &chi; is a word of length at most 1 on &Chi;. The edge (&sigma;<sub>1</sub>,&chi;,&sigma;<sub>2</sub>) is said to <dfn>begin</dfn> at &sigma;<sub>1</sub>, to <dfn>end</dfn> at &sigma;<sub>2</sub>, and to be <dfn>labelled by</dfn> &chi;.</li>
<li>In the case where M is a 6-tuple, i.e. &Lambda; is present, &Lambda; is a function with domain a subset of &Sigma; The value of &Lambda;(&sigma;), where defined, is called the <dfn>label</dfn> of &sigma;.
</ol>
<p>A <dfn>path</dfn> is a sequence of elements of &Tau; such that each transition after the first begins at the state where the previous transition ends. The path is said to begin at the state that begins the first transition, and end at the state that ends the final transition in the path. The <dfn>signature</dfn> of the path is the concatenation of the words that label the transitions. For every state &sigma; &isin; &Sigma; we also allow the empty path: its signature is the empty word.</p>
<p>A word on &Chi; is said to be <dfn>accepted by <i>M</i></dfn> if it is the signature of a path that begins in &Alpha; and ends in &Omega; The <dfn>language</dfn> <i>L(M)</i> of <i>M</i> is the set of all words on &Chi; accepted by M.</p>
<p>A set of words on &Chi; is a <dfn>regular</dfn> or <dfn>rational</dfn> language (or set) if it is the language of some finite state automaton. (Other definitions of regular languages are possible, but this one is convenient here).</p> 
<p>Since the nature of the elements of &Sigma; is irrelevant to the language of <i>M</i>, it is usual to take &Sigma; to be some initial segment [1..n] of the set of natural numbers. However, in the case where practical use is to be made of an FSA it is likely we shall want to associate other information with the states of the FSA. This is the reason for the presence of the function &Lambda; in the definition given here. Although in principle it is not needed, (since any computational procedure could create and store the necessary function &Lambda; for itself), it is helpful to regard &Lambda; as part of the FSA, since then algorithms which manipulate FSA can then also manipulate the function &Lambda; appropriately. Many of MAF's computations depend heavily on this function.
</p>
<h3>Types of FSA</h3>
<h4>DFA</h4>
<p>A <dfn>(complete) deterministic finite state automaton</dfn>, or <dfn>DFA</dfn>, is a finite state automaton where &Alpha; has <em>exactly one</em> member, every element of &Tau; is labelled by a word of length 1, and for every &sigma;<sub>1</sub> &isin; &Sigma; and every word &chi; of length 1 on &Chi; there is <em>exactly one</em> state &sigma;<sub>2</sub> such that (&sigma;<sub>1</sub>,&chi;,&sigma;<sub>2</sub>) &isin; &Tau;.</p>
<h4>PDFA</h4>
<p>A <dfn>partial deterministic finite state automaton</dfn>, or <dfn>PDFA</dfn>, is a finite state automaton where &Alpha; has <i>at most one</i> member, every element of &Tau; is labelled by a word of length 1, and for every &sigma;<sub>1</sub> &isin; &Sigma; and every word &chi; of length 1 on &Chi; there is <em>at most one</em> state &sigma;<sub>2</sub> such that (&sigma;<sub>1</sub>,&chi;,&sigma;<sub>2</sub>) &isin; &Tau;.</p>
<h4>MIDFA</h4>
<p>A <dfn>multiple initial state deterministic finite state automaton</dfn>, or <dfn>MIDFA</dfn>, is a finite state automaton where every element of &Tau; is labelled by a word of length 1, and for every &sigma;<sub>1</sub> &isin; &Sigma; and every word &chi; of length 1 on &Chi; there is <em>exactly one</em> state &sigma;<sub>2</sub> such that (&sigma;<sub>1</sub>,&chi;,&sigma;<sub>2</sub>) &isin; &Tau;.</p>
<h4><a name="index_automaton"></a>Index automaton</h4>
<p>An <dfn>index automaton</dfn> is a DFA in which the transition function can also take negative values. If such a value is encountered then the automaton is considered to have entered the failure state 0, and the corresponding positive value is taken to be an index into an array of "rewriting rules" of the form <i>u</i>=<i>v</i> where <i>u</i> and <i>v</i> are both words in A*. In this case the word <i>u</i> will be the most recent n symbols that have been read for some finite n, and we erase these last n symbols from our input and replace them with the word <i>v</i>, and either resume reading the word from the begining of <i>v</i> (if we can remember what state we were in prior to reading the first symbol of <i>u</i>), or from the beginning of the amended word if not.</p>
<h4>Remarks</h4>
<p>It is easy to convert a PDFA into a DFA that accepts the same language, by adjoining a new state, called the <dfn>failure state</dfn> to &Sigma;. In the usual case, where the original set &Sigma;={1..n} for some n, the failure state is 0. If &Alpha; is empty the failure state is adjoined to &Alpha;. For every &sigma; &isin; &Sigma; and word &chi; of length 1 on &Chi; for which there is currently no transition the transition (&sigma;,&chi;0), is adjoined to &Tau;.</p>
<p>In a DFA or MIDFA the set &Tau; can be used to define a function with domain &Sigma;*&Chi; and codomain &Sigma; called the transition function. The image of (&sigma;,&chi;) is denoted by &sigma;^&chi; and is the unique &sigma;<sub>2</sub> such that(&sigma;,&chi;,&sigma;<sub>2</sub>) &isin; &Tau; (where &chi; is an element of &Chi; in the first case, and the corresponding word of length 1 in the second case). MAF typically stores the elements of &Tau; as vectors of values of this function, since it reduces significantly the amount of data that needs to be stored, and is convenient for the most common use of the set &Tau;. In theory this has no bearing on the operation of MAF, since it is an "implementation detail". However, you should be aware that some operations on FSA that have very simple conceptual implementations, such as "reversing" an FSA, are difficult to implement, and hence slow operations, as a result of this.</p>
<p>MIDFA automata are used by MAF for with coset systems. Typically the initial state represents an element of the subgroup. Any language recognised by a MIDFA can be also be recognised by a DFA, but MAF needs the additional information given in labels for the initial states for some of its computations.</p>
<p>An automaton not falling into any of the three categories above is said to be non-deterministic. The abbreviation for such an automaton is NFA. It is a standard theorem in automata theory that any regular language can be recognised by a DFA, and there is an algorithm for constructing a DFA with the same language as any given NFA. MAF currently only supports DFA and MIDFA automata. In all MAF automata 0 is present as a failure state, even if this state is inaccessible.</p>
<h3><a name="product"></a>2-variable automata</h3>
<p>A <dfn>2-stringed automaton</dfn>,  <dfn>2-variable automaton</dfn>, or <dfn>product automaton</dfn> is a finite state automaton whose alphabet is a set of ordered pairs of symbols from a base alphabet to which a new  symbol, called the <dfn>padding symbol</dfn>, has been adjoined. The representation of this symbol is usually fairly irrelevant: MAF uses the <code>_</code> symbol in output files. Use of the <code>$</code> symbol is common in this context, and some MAF source code thinks of the padding symbol as being <code>$</code>: this has no bearing on the operation of MAF, but might be useful to know if you study the source code). The new alphabet contains all ordered pairs of symbols from the augmented alphabet, except for the pair consisting of two padding symbols. </p>
<p>The language of such an automaton can be considered as a set of pairs of words over the base alphabet; pairs of words are read by the automaton by reading at each stage a pair of symbols, one from each string. If one word is longer than the other, then the shorter word is padded out with padding symbols, until the two words are equal in length.</p>
<p>This construction can be generalised to allow for n-variable automata, but MAF has need for automata with more than 2 variables and does not support them directly (the GAP interface for MAF will support them).
</p>
<p>The definition above does not specify any ordering of the new alphabet, but in practice we shall certainly need one. A simple example will be of more use than a formal definition here. So, suppose our original alphabet is [a,b,B], and we use _ as the padding symbol. Our new "product" alphabet contains 15 symbols which are [(a,a), (a,b), (a,B), (a,_), (b,a), (b,b)..., (B,_), (_,a) ,(_,b), (_,B)]. We always put the padding symbol at the end of the ordinary alphabet, and order the product alphabet in the manner shown (not that this is the best order that could have been chosen in the present author's opinion, but it is the one used by KBMAG, so we are stuck with it). Code which wanted to read the word pair (b*b,B) would notionally turn this into the single word (b,B)*(b,_) in our new alphabet. We can either get the program that interprets our automaton to handle the translation from our original two symbols into the one symbol from the product alphabet itself, or we can pre-compute a translated word for it to read, so that it does not even have to know that "really" it is reading two words from some other alphabet. On the whole the former approach is better, because it will save time in the case where the program might not need to read the whole word to determine whether the input is accepted, but the latter would make it easier to support automata with arbitrary "arity".</p>

<h3>Algebra of FSA</h3>
<p>A remarkable property of FSA, and one of the main reasons they are useful, is that it is possible to manipulate them algebraically. For example, given two FSA <i>f</i>, <i>g</i> that read the same alphabet it is possible to construct the FSA <i>h</i> which accepts a word precisely when both <i>f</i> and <i>g</i> accept the word. Similarly one can construct the FSA which accepts a word if either <i>f</i> or <i>g</i> do, or the FSA which accepts a word if it is the concatenation of a word accepted by <i>f</i> and a word accepted by <i>g</i>, or the FSA which accepts the words <i>f</i> and <i>g</i> reject, and so on. There are also ways to manipulate 2-variable FSA, and to convert 1-variable FSA into 2-variable FSA. Perhaps the most important of these is what is usually called the "there exists" FSA. This accepts a word <i>u</i> if the 2-variable FSA on which it is based accepts the word pair (<i>u</i>,<i>v</i>) for some <i>v</i>. </p>
<p>Use of the phrase "the FSA" requires justification since there are infintely many FSA which accept any particular regular language. However, out of all these FSA there is one "canonical" PDFA. For any language that can be recognised by an FSA the number of states in an PDFA that recognises the language is bounded below. A PDFA which attains this bound is said to be <dfn>minimised</dfn>.  The canonical PDFA is minimised, and the states are numbered in a particular sequence known as BFS, which stands for breadth first sequence (or search). If a DFA or MIDFA has the BFS property, then the initial states are an initial segment of &Sigma;, and the set of values 1^a,1^b,1^c,...2^a,2^b,... is also an initial segment of &Sigma;. Given any FSA an algorithm exists which will create the corresponding canonical PDFA. Generally algebraic operations on FSA first create a "prototype" PDFA which accepts the correct language but which probably has too many states (though the method of construction means it usually will already be BFS), and which then "minimise" the prototype PDFA to return the canonical PDFA for that language. </p>
<p>Two particularly important properties which are posessed by the canonical PDFA are that all its states are <dfn>accessible</dfn>, which means that every state can be reached from an initial state, and that none of its states are <dfn>failing</dfn>. A state is failing if it is not an accepting state and no accepting state can be reached from it.  An FSA with both of these properties is said to be <dfn>trim</dfn>, but an FSA can be trim without being minimised. In practice, since PDFA are implemented as a DFA with one failure state 0, these definitions are modified to exclude the 0 state from consideration.</p>
<p>In fact we do sometimes want a non-minimal FSA. The most common reason for doing this is that we have labelled the states in some way and that as well as just the accept/reject division we want to know the label of any accepted word. The algorithm which finds the canonical DFA for a language does not pay any attention to the labels. Fortunately it can easily be modified slightly to do so. In MAF automata are generally constructed so that they are BFS, and minimised subject to the requirement that labels are preserved.</p>

</body>
</html> 
