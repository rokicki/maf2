<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>MAF : Reference (Usage) : Usage information for RWS utilities</title>
<link type="text/css" rel="StyleSheet" href="site.css">
<link rel="Start" type="text/html" href="MAF.html"> 
<link rel="Chapter" type="text/html" href="Preface.html" title="Introduction">
<link rel="Chapter" type="text/html" href="overview.html" title="An overview of MAF">
<link rel="Chapter" type="text/html" href="reference.html" title="MAF Reference">
<link rel="Chapter" type="text/html" href="MAF.html#tutorials" title="Tutorials">
<link rel="Chapter" type="text/html" href="background.html" title="Background material">
<link rel="Chapter" type="text/html" href="MAF.html#appendices" title="Appendices">
<link rel="Copyright" type="text/html" href="copyright.html"> 
<link rel="Contents" type="text/html" href="MAF.html"> 

<link rel="Prev" type="text/html" href="automata_usage.html" title="Usage: automata">
<link rel="Next" type="text/html" href="fsa_usage.html" title="Usage: FSA utilities">
<script type="text/javascript" language="Javascript" src="site.js">
</script>
</head>
<body onload="OnPageLoad()" onunload="OnPageUnload()">
<a href="MAF.html">MAF</a> : <a href="reference.html#usage">Reference (Usage)</a> : Usage information for RWS utilities
<h2>Usage information for RWS utilities</h2>
<p>This page contains detailed usage information for MAF components that take their input from an "input file"
(rewriting system). Most of the utilities also requires one or more of the automata usually created by <tt>automata</tt> to be present.</p>

<h3><tt>fsafl</tt></h3>
<p>The utility <tt>fsafl</tt> which can be used to create an automaton that accepts any desired finite language on some alphabet, and ought, in theory, to be listed in this section, because it takes (some of) its input from a rewriting system. However, as its name suggests, the utility is intended to be an FSA utility, and is effectively one, so is described in the <a href="fsa_usage.html#fsafl">FSA utilities usage</a> section.

<h3><a name="gpaxioms"></a><tt>gpaxioms</tt></h3>
<p><kbd>gpaxioms <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [-midfa] [-serial | -hybrid | -parallel] [-check_inverses] <i>groupname</i> [<a href="standard_options.html#coset_systems">-cos</a> [<i>subsuffix</i>]]</kbd></p>
<p>Validate a previously computed automatic structure for a group or coset system by checking the multiplication defined by the structure satisfies the group axioms. The <kbd>-midfa</kbd> option is only relevant to a coset system; it causes the validation to be performed using the MIDFA multiplier rather than the determinised multiplier. <tt>gpaxioms</tt> supports three different techniques for building the composite multipliers that the axiom check relies upon. The <kbd>-hybrid</kbd> option is the default as this usually works well. The <kbd>-parallel</kbd> option is sometimes much faster, but may require much more memory and is also often slower. The <kbd>-serial</kbd> option uses the least memory, but is usually the slowest method of performing the check, but 
may be better if the alphabet is large.</p>
<p>MAF does not usually check the relators implied by the <code>inverses</code> field of the input file, i.e. the relators of the form <i>g*g^-1</i>, when it is checking axioms. This is because MAF cannot possibly produce a multiplier which would fail these checks. To make MAF perform these checks specify the <kbd>-check_inverses</kbd> option.</p>

<h3><a name="gpcclass"></a><tt>gpcclass</tt></h3>
<p><kbd>gpcosets <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] <a href="standard_options.html#reduction_method">[reduction_method]</a> [-conjugator] <i>groupname</i> [<a href="standard_options.html#coset_systems">-cos</a> [<i>subsuffix</i>]]</kbd></p>
<p>Compute the conjugacy classes of the finite group described by the input file <tt><i>groupname</i></tt>,
or , if the <kbd>-cos</kbd> is specified, the conjugacy classes modulo the finite index subgroup <tt><i>groupname</i>.<i>subsuffix</i></tt>. The latter usage does not make much sense unless the subgroup is normal,
but <tt>gpcclass</tt> does not require this.</p>
<p>An automaton that can perform word reduction for the relevant rewriting system must previously have been computed.</p>
<p>The computed FSA has the same states and transitions as the coset table computed by <tt>gpcosets</tt>.
The accepted language consists of words that are equal as elements to the minimal representative of the conjugacy class of the element. Every state is labelled by its conjugacy class representative. The FSA is output to <tt><i>groupname</i>.cclasses</tt>. A file <tt><i>groupname</i>.cc_statistics</tt> containing a summary of the conjugacy information is also generated.</p>
<p>If the <kbd>-conjugator</kbd> option is specified an additional 2-variable FSA is computed and output to <tt><i>groupname</i>.conjugator</tt>. This accepts the word pair (<i>u</i>,<i>v</i>) at a state labelled with <i>w</i> if <i>u</i> and <i>v</i> are accepted words and <i>v</i> is the least accepted word such that <i>v^-1*u*v</i> reduces to the conjugacy class representative, which is <i>w</i>. This FSA is not computed by default
because it can be very large.</p>

<h3><a name="gpcosets"></a><tt>gpcosets</tt></h3>
<p><kbd>gpcosets <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] <a href="standard_options.html#reduction_method">[reduction_method]</a> <i>groupname</i> [<a href="standard_options.html#coset_systems">-cos</a> [<i>subsuffix</i>]]</kbd></p>
<p>Compute the coset table for the subgroup of finite index of <i>groupname</i> specified in the <a href="substructure_files.html">substructure file</a> <i>groupname</i>.<i>subsuffix</i>. If <kbd>-cos</kbd> is omitted the subgroup is the trivial subgroup. <tt>gpcosets</tt> will exit immediately with a diagnostic if asked to create an infinite coset table, or one that is too large to fit in memory. A method of performing word reduction and a word acceptor are required, so the relevant input file should previously have been processed with <tt>automata</tt>. The coset table is standardised as though the word-ordering was shortlex, (because it has the BFS property). However, the coset representatives can be computed, because each coset is labelled with the final generator appearing in the reduced word for that coset, and these labels are and are correct for the word-ordering used by the coset system.</p>
<p><tt>gptcenum</tt> can also create the coset table.</p>

<h3><a name="gpdifflabs"></a><tt>gpdifflabs</tt></h3>
<p><kbd>gpdifflabs <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] <a href="standard_options.html#reduction_method">[reduction_method]</a> <i>groupname</i>  <a href="standard_options.html#input_file">-i | input_file</a> <a href="standard_options.html#output_file">[-o | <i>output file</i>]</a></kbd></p>
<p><tt>gpdifflabs</tt> can be used to label all the states of multipliers with the corresponding word-differences. An automaton able to perform word reduction must previously have been computed.
Either <tt>stdin</tt> (if you specify <kbd>-i</kbd>), or <tt>input_file</tt> (otherwise), should contain a
2-variable FSA. <tt>gpdifflabs</tt> computes and FSA with the same accepted language but with states labelled by the difference between the left and right words for each state. The input file should be a multiplier FSA for some group element, but might be a multiplier for a coset system for the group. If you attempt to label a
2-variable FSA where the states are not associated with a unique word-difference and the group is infinite then <tt>gpdifflabs</tt> will probably run until memory is exhausted. <tt>gpdifflabs</tt> is one of the rare RWS utilities that does not work directly with coset systems: you can use it to label the states of a multiplier FSA from a coset system, but you must use a reduction automaton from the underlying group to do this, since word-differences are group elements, not cosets. For example to label a coset multiplier <tt>groupname.cos.migm</tt> you might use the following command:</p>
<p><kbd>gpdifflabs <i>groupname</i> <i>groupname</i>.cos.migm</kbd></p>
<p>The default output file is <tt><i>input_file</i>.difflabs</tt>, so the command line above would create <tt><i>groupname</i>.cos.migm.difflabs</tt>.</p>
<p>Since most FSA that you might want to run this program against using <tt>groupname</tt> as the rewriting system will also have a name starting with <tt>groupname</tt> <tt>gpdifflabs</tt> will allow you to specify
just the suffix part of the input file. So the command above could be replaced by:</p>
<p><kbd>gpdifflabs <i>groupname</i> cos.migm</kbd></p>
<p>The default output file is <tt><i>input_file</i>.difflabs</tt>, so both the command lines above would create <tt><i>groupname</i>.cos.migm.difflabs</tt>.</p>
<h3><a name="gpgeowa"></a><tt>gpgeowa</tt></h3>
<p><kbd>gpgeowa <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] <a href="standard_options.html#reduction_method">[reduction_method]</a> [-near | -n] <i>groupname</i></kbd></p>
<p>This program attempts to construct a geodesic word-acceptor for a group after an automatic structure using a geodesic word-ordering has been computed. The geodesic word-acceptor accepts a word if it is <em>a</em> shortest word for the corresponding group element (rather than <em>the</em> (necessarily shortest) word that is minimal under the word-ordering). A group for which such a word-acceptor can be found, and for which this word-acceptor is part of an automatic structure is said to be <dfn>strongly geodesically automatic</dfn>. Cannon showed that word-hyperbolic groups have this property, and a paper of Panos Papasoglu proved that groups with this property are also word-hyperbolic. Word-hyperbolic groups are shortlex automatic for any choice of generating set. In fact <tt>gpgeowa</tt> also computes a two-variable automaton that accepts a pair of words if and only if they are equal geodesics: it is easy to see that if we can construct this automaton we can also construct the desired automatic structure by composition with the multiplier from the automatic structure previously computed.</p>

<p>Successful completion of this program against a suitable input file can therefore prove that a group is word-hyperbolic, although it does not provide an estimate of the hyperbolic constant (whatever that may be).</p>
<p>If the group is not word-hyperbolic, then <tt>gpgeowa</tt> will not terminate and will have to be stopped by pressing &lt;Ctrl+C&gt;, otherwise it will continue to run forever, consuming ever greater amounts of memory until it runs out of address space and crashes. This happens even when a geodesic word-acceptor that is not part of an automatic structure exists. This will happen for many infinite groups, for example it happens with any group with a subgroup that is the free abelian group of rank 2.</p>
<p>The input file <kbd><i>groupname</i></kbd> must contains a rewriting system for a group and use a geodesic word-ordering, and the corresponding automatic structure must have been successfully computed for this file (usually with <tt>automata</tt>).</p>
<p>Input is from <tt><i>groupname</i>.wa</tt>, <tt><i>groupname</i>.diff2</tt>, and from one of the automata capable of performing word reduction. Output (when successful) is to the three files <tt><i>groupname</i>.geowa</tt>, which contains the geodesic word-acceptor, <tt><i>groupname</i>.geopairs</tt>, which contains a two-variable automaton whose language consists of all pairs of equal geodesic words in the group generators, and <tt><i>groupname</i>.geodiff</tt>, which contains a two-variable word-difference machine, consisting of the word-differences and transitions necessary for constructing <tt><i>groupname</i>.geopairs</tt>.</p>
<p>If the <kbd>-near</kbd> option is specified, then two  additional 2-variable automaton is output to <tt><i>groupname</i>.near_geopairs</tt> and to <tt><i>groupname</i>.near_geodiff</tt>. The first of these accepts a  pairs of words (<i>u</i>,<i>v</i>) if and only if <i>u</i> and <i>v</i> are geodesic and <i>u*x=v</i> for <i>x</i> either the identity or some generator. It is in fact the geodesic general multiplier, except that the states are labelled only with words rather than a list of words, and the accepting labels will omit any reducible generators. The second automaton is the word-difference machine of this multiplier.</p>
<p>MAF uses a different algorithm from KBMAG to calculate geodesic automata.</p>
<p><tt>automata</tt> does not try to generate these automata itself, because they only exist for groups which are "word-hyperbolic", which many automatic groups are not. Even for finite groups, which certainly are word-hyperbolic, these automata can be very large, and can take an extremely long time to generate. To answer questions about geodesic words it will sometimes be better just to build an automaton that always exists (even for groups that are not automatic): the "outer geodesic word-acceptor". This a word-acceptor, not part of an automatic structure, which certainly accepts all geodesic words, but which also usually accepts some words that are not geodesic. This word-acceptor can be constructed using the <a href="#gpwa"><tt>gpwa</tt></a> utility with <kbd>-outer_geodesic</kbd>. Enumerate the words and use reduction to discover the ones that really are geodesics.</p>


<h3><tt>gpminkb</tt></h3>
<p><kbd>gpminkb <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] <i>groupname</i>[<a href="standard_options.html#coset_systems">-cos</a>  [<i>subsuffix</i>]]</kbd><br>
<p>This program calculates some automata derived from an automatic structure. The automata constructed are <tt><i>groupname</i>.diff1c</tt>, <tt><i>groupname</i>.diff2c</tt>, <tt><i>groupname</i>.minred</tt>, <tt><i>groupname</i>.minkb</tt> and <tt><i>groupname</i>.maxkb</tt> (which is new to MAF). Refer to <a href="automata_FSA.html">Output files (groups and monoids)</a> for details of these automata. If the <kbd>-cos</kbd> option is specified then the first two files have suffix <tt>.midiff1c</tt> and <tt>.midiff2c</tt> instead. Refer to <a href="cosets_FSA.html">Output files (coset systems)</a> instead, for details of the automata <tt>gpminkb</tt> creates in this case.
<p>If you use <tt>automata</tt> these automata are computed automatically when an automatic structure is computed, but if you use the KBMAG compatibility programs <tt>autgroup</tt> or<tt>autcos</tt> to generate an automatic structure, then you may need to invoke this utility separately.</p>

<h3><a name="gpmorphism"></a><tt>gpmorphism</tt></h3>
<p><kbd>gpmorphism <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> <a href="standard_options.html#reduction_method">[reduction_method]</a> [-check_index] <i>sourcerws</i> <i>targetrws</i> [output_file]</kbd></p>
<p><tt>gpmorphism</tt> tries to compute mappings from the generators of <tt>sourcerws</tt> to words in the generators of <tt>targetrws</tt>, in which the axioms of <tt>sourcerws</tt> are satisfied. An automaton that solves the word problem and permits word reduction for <tt>targetrws</tt> must previously have been computed. If successful the computed mapping defines a homomorphism between the groups or monoids corresponding to <tt>sourcerws</tt> and <tt>targetrws</tt>.
<p>If the <kbd>-check_index</kbd> is specified <tt>gpmorphism</tt> performs a coset enumeration on the subgroup generated by the images of the generators, so that it can be checked if the mapping is an epimorphism.</p>
<p>Output is sent to <tt>stdout</tt> by default, but you can specify an output file if desired. The output is a GAP list of lists, each list consists of the images of the generators of <tt>sourcerws</tt>. If the <kbd>-check_index</kbd> option is used, then there is an additional level of nesting, and each list of generator images is followed by the index. It is possible the coset enumeration will fail, and in this case the index is shown as 0. You can try computing the index of the subgroup using either a coset system, or <tt>gptcenum</tt>.</p>
<p><tt>gpmorphism</tt> will not list every possible morphism: it will exclude any morphism where the first generator that is not mapped to the identity is mapped to a word which is obviously not a conjugacy class representative; if <tt>gpcclass</tt> has been run against <tt>targetrws</tt> then the image of the first generator will be a conjugacy class representative. Ideally <tt>gpmorphism</tt> would only list one representative amongst morphisms which were equivalent modulo an automorphism of <tt>targetrws</tt>, or at least modulo an inner automorphism, the one in which every generator image was as early as possible in the word ordering of <tt>targetrws</tt>. It would not be not easy to implement this. However, <tt>gpmorphism</tt> will exclude any morphism in which an obvious conjugation shows that the images are not minimal.</p>
<p><tt>gpmorphism</tt> computes the total length of the images of the group generators, (i.e. it only counts the length for one out of each pair of mutually inverse monoid generators). It first looks for morphisms where this length is 0 (i.e. the trivial morphism), and then 1,2 and so on. This ensures that if <tt>targetrws</tt> is infinite then any particular morphism will be found at some point.</p>

<h3><tt>gpmult</tt></h3>
<p><kbd>gpmult <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] [<a href="standard_options.html#coset_systems">-cos</a>] [-migm] [-pres | -2 | -sub | -word expression] <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p>This program assumes that the automatic structure has already been created for the input file, i.e. that <tt><i>groupname</i>.gm</tt> has been created successfully, or <tt><i>groupname</i>.<i>cossuffix</i>.gm</tt> if you are using the <kbd>-cos</kbd>option. <tt>gpmult</tt> can compute various additional multiplier automata which may sometimes be useful:</p>
<ul><li>
<p>In no special command line options are specified <tt>gpmult</tt> computes the individual multiplier automata, for the monoid generators of the group, of which the rewriting system defining the group is in the file <kbd><i>groupname</i></kbd>, using suffixes <kbd>.m1</kbd> to <kbd>.m<i>n</i></kbd> where <kbd><i>n</i></kbd> is one more than the number of generators listed in the <tt>generatorOrder</tt> field of the <tt><i>groupname</i></tt>. The final multiplier is the equality multiplier, which accepts <i>(u,v)</i> if and only if <i>u = v</i> and <i>u</i> is accepted by the word-acceptor. 
<li><p>If the <kbd>-2</kbd> option is specified then instead MAF computes the general multiplier for words of length 1 and 2, <kbd><i>groupname</i>.gm2</kbd>. This automaton is not needed in MAF, but if it is available certain other multipliers may be computed more quickly. It may take a very long time to generate this multiplier. In this usage <tt>gpmult</tt> is equivalent to KBMAG's <tt>gpgenmult2</tt>, or to <tt>gpmigenmult2</tt> if you also use the <kbd>-cos</kbd> option and <kbd>-migm</kbd> options. In fact MAF versions of those utilities are also provided, as also is <tt>gpmimult</tt>, but there is no reason to use them and they are not described in detail in this section.</p>
<li><p>If the <kbd>-sub</kbd> option is specified, then <tt>gpmult</tt> reads the substructure file <tt><i>groupname</i>.<i>subsuffix</i></tt>. It then generates the general multiplier in the group, for the subgroup generators,  their inverses, and the identity element and outputs it to <tt><i>groupname</i>.<i>subsuffix</i>.gmg</tt>. This option cannot be used when the <kbd>-cos</kbd> option is specified, because <tt>gpmult</tt> only allows one subgroup suffix to be specified. However, if you want to generate coset multipliers for a specific collection of words you can do so by specifying the coset system directly and using  the <kbd>-sub</kbd> option as well. For example the command line <kbd>gpmult -migm <i>groupname</i>.cos -sub sub1</i></kbd> would build the multipliers for the words specified as subgroup generators in <tt><i>groupname</i>.sub1</tt> relative to the subgroup specified in <tt><i>groupname</i>.sub</i></tt>
<li>If the <kbd>-pres</kbd> option is specified then <tt>gpmult</tt> calculates the multipliers for the group relators. Doing this is similar to verifying the automatic structure is correct  using <tt>gpaxioms</tt>, since the multipliers should all have the same accepted language as the identity multiplier.
<li>If the <kbd>-word</kbd> option is specified <tt>gpmult</tt> calculates the multiplier for the specified word.</li>
</ul>
<p>When the <kbd>-cos</kbd> option is used <tt>gpmult</tt> will, by default, compute the new multipliers using the determinised general multiplier for the coset system. If instead you would like a MIDFA multiplier then specify the <kbd>-migm</kbd> option.

<h3><a name="gporder"></a><tt>gporder</tt></h3>
<p><kbd>gporder <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [-steps] <a href="standard_options/html#reduction_method">[ <i>reduction_method</i>]</a> <i>rwsname</i> [<a href="standard_options.html#coset_systems">-cos</a> [<i>subsuffix</i>]] [-i | -read filename | word]</kbd></p>
<p>This program can be used to find the order of torsion elements.  If the <kbd>-cos</kbd> option is used then the order modulo the subgroup is found, i.e. the least power of the word which is in the subgroup. It is assumed that <tt>automata</tt> has previously run, and that is has output at least one FSA which makes at least provisional word reduction possible. If not, or if you specify that <tt>gporder</tt> should use an automaton that is not available, then <tt>gporder</tt> will exit with an error message and error level.</p>
<p><tt>gporder</tt> reduces successive powers of the word(s) until it reaches the identity word. If the group is infinite and a word-acceptor is available MAF will also check, for each power it computes, whether the word-acceptor will accept that word infinitely often - which proves the element is not a torsion element. If the maximum word length is exceeded before either of these things happens then the program will crash. The program does not yet attempt to use information about the order of a finite group to work more efficiently, and the
method used to detect that an element is not a torsion-element is not yet as good as it could be.</p>
<p>If an input file containing a GAP list of words is supplied <tt>gporder</tt> will calculate the orders of all the words in the list and output a list consisting of the words and the corresponding order.</p>
<p>If the <kbd>-i</kbd> option is used <tt>gporder</tt> runs in an interactive mode, and will report the order of words as you enter them. Each word should be terminated by a comma - pressing the &lt;Enter&gt; or carriage return key has no effect otherwise, since MAF will assume that the word whose order is to be found is to be continued on the next line. To leave the program enter a ; or hit Ctrl+C.</p>
<h3><a name="gpsublowindex"></a><tt>gpsublowindex</tt></h3>
<p><kbd>gpsublowindex <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a>  [-start n] -stop <i>n</i> [-named]  [-simplify] [ -rws | -pres]  <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>gpsublowindex</tt> is a utility which can be used to find low index subgroups of a group, and generate  substructure files for them.
It finds conjugacy class representatives of the subgroups which have an index between 2, or the value specified for <kbd>-start</kbd>, and the value specified for <kbd>-stop</kbd>, and generates substructure files for them. The substructure file will be for a simple coset system unless the <kbd>-named</kbd> option
is used. If the <kbd>-simplify</kbd> option is used MAF will eliminate as many of the
specified generators as it can before generating the substructure file.
If the <kbd>-rws</kbd> option is used a new input file is generated, which presents the
specified subgroup. The <kbd>-pres</kbd> option is similar but generates GAP source code.
The new substructure files will be output to <tt><i>groupname</i>.sublow_i<i>n1</i>_<i>n2</i></tt>, where
<i>n1</i> is the index of the subgroup and <i>n2</i> is a sequence number. If a <i>subsuffix</i>
is specified the files will be output to <i>groupname</i>.<i>subsuffix</i>_i<i>n1</i>_<i>n2</i> instead.

<h3><a name="gpsubmake"></a><tt>gpsubmake</tt></h3>
<p><kbd>gpsubmake <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a>  -derived | -named | -power <i>n</i>  <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>gpsubmake</tt> is a utility which can be used to generate certain substructure files for an input file describing a group.</p>
<ul><li><p>If the <kbd>-derived</kbd> option is specified, a substructure file for the derived subgroup is generated. The coset system will be a normal closure coset system. It is perfectly possible that MAF will not be able to process this successfully, since it might be the case that the derived subgroup is not finitely generated. The new substructure file will be output to <tt><i>groupname</i>.sub_derived</tt> unless a value is specified for <kbd><i>subsuffix</i></kbd>.</p>
<li><p>If the <kbd>-named</kbd> option is specified, then either <tt><i>groupname</i>.sub</tt>, if no value is specified for <kbd><i>subsuffix</i></kbd>, or <tt><i>groupname.subsuffix</i></tt> otherwise, must be the substructure file for a simple coset system that has already been successfully processed by <tt>automata</tt>.
A new substructure file for the same subgroup is created, using named generators. The new generators will be
taken from <tt><i>groupname.subsuffix</i>.rws.simplify</tt> if this exists, or  <tt><i>groupname.subsuffix</i>.rws</tt> otherwise. The new substructure file is given the name <tt><i>groupname.subsuffix</i>_named</tt></li>
<li><p>If the <kbd>-power <i>n</i></kbd> option is specified then <i>n</i> should be a small integer. MAF attempts to find a finite collection of words of the form <i>w<sup>n</sup></i> that generate a finite index
normal subgroup which appears to contain all <i>n</i>th powers. The substructure file is for a simple coset system. If new substructure file will be output to <tt><i>groupname</i>.sub_power_<i>n</i></tt> unless a value is specified for  <kbd><i>subsuffix</i></kbd>.</p>
</ul>

<h3><tt>gpsubpres</tt></h3>
<p><kbd>gpsubpres <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> <a href="standard_options.html#reduction_method">[<i>reduction_method</i>]</a> [-rs | -rws] [-schreier] [-no_composite] [-kb] [-pres [-keep]] <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>gpsubpres</tt> computes a presentation of the subgroup described in <tt><i>groupname</i>.<i>subsuffix</i></tt> (or <tt><i>groupname</i>.sub</tt> if <kbd><i>subsuffix</i></kbd> is not specified). The presentation will normally be output as a new input file named <tt><i>groupname</i>.<i>subsuffix</i>.rws</tt> , but if the <kbd>-pres</kbd> option is used it is output as GAP source code to <tt><i>groupname</i>.<i>subsuffix</i>.pres</tt>. MAF cannot itself process files in this alternative format.</p>
<p><tt>gpsubpres</tt> can use three methods to compute a presentation:</p>
<ul><li>By default <tt>gpsubpres</tt> will compute the presentation using a previously computed automatic structure for the coset system. If the substructure file did not have named subgroup generators, or if the automatic structure is generated by <tt>autcos</tt> or <tt>autgroup</tt> instead of <tt>automata</tt>, or you specify the <tt>-schreier</tt> option, then the presentation is on the set of Schreier generators formed by the words labelling the initial states of the MIDFA form of the general multiplier for the coset system, otherwise it is on the generators specified in the substructure file. (These words must generate the subgroup, otherwise the coset multiplier would be invalid, since some subgroup elements would not appear to be in the identity coset.) If the <kbd>-no_composite</kbd> option, which is only relevant to this method of computing the subgroup presentation, MAF attempts to compute the presentation without computing all the multipliers for the relators, and instead forms the relators which might arise in those multipliers by considering just the initial states. This is often much faster, but it can happen that the number of such relators is very large. If that happens MAF will revert to the usual method of computing the subgroup presentation. Presentations generated using the <kbd>-no_composite</kbd> option will typically have more redundant relators. If the subgroup has finite index then MAF may not form the composites in any case. It may simply be quicker to multiply all the coset representatives by all the relators. MAF will do this if it believes this will save time.</li>
<li>If the subgroup has finite index, then you can use the <kbd>-rs</kbd> option to generate a presentation using the Reidemeister-Schreier algorithm. Such presentations always use a set of Schreier generators. Typically presentations computed like this have many more generators than presentations computed by the first method even when Schreier generators in both cases.</li>
<li>If the coset system was at least partially confluent, and named subgroup generators were used, then the set of <i>H</i>-equations in the <tt>.kbprog</tt> file produced by <tt>automata</tt> present the subgroup. The <kbd>-rws</kbd> option can be used to generate an input file containing this set of equations. Typically presentations computed by this method will contain more equations than presentations computed using either of the other two methods, but the equations may well be much shorter.</li>
</ul>
<p>If the <kbd>-pres</kbd> option is used the generators are given new names, even if the presentation is on named subgroup generators, unless you also specify <kbd>-keep</kbd>, in which case MAF will attempt to keep as many generator names the same as possible. Since GAP uses group rather than monoid generators, at least one of each pair of mutually inverse generators will disappear.</p>
<h3><tt>gpsubwa</tt></h3>
<p><kbd>gpsubwa <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] <a href="standard_options.html#reduction_method">[reduction_method]</a> <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>gpsubwa</tt> attempts to compute a subgroup word-acceptor for the subgroup <i>H</i> of the automatic group <i>G</i> (whose automatic structure must previously have been computed), where the rewriting system for <i>G</i> is defined in <kbd><i>groupname</i></kbd>, and the generators for <i>H</i> are defined in the file, <kbd><i>groupname</i>.<i>subsuffix</i></kbd>, where <kbd><i>subsuffix</i></kbd> defaults to <kbd>sub</kbd>. See <a href="substructure_files.html">Substructure files</a> for information on the format of the latter file.) The computed automaton is output to the file <kbd><i>groupname</i>.<i>subsuffix</i>.wa</kbd>.</p>
<p><kbd>gpsubwa</kbd> requires the word-acceptor and general multiplier for an automatic structure of <i>G</i>, which it inputs from the files <kbd><i>groupname</i>.wa</kbd> and <kbd><i>groupname</i>.gm</kbd>.  These need to be computed first by running <tt>automata</tt> or its constituents. It also requires word-reduction automata for <i>G</i> and for cosets of <i>H</i> in <i>G</i>, as described above. These are input, respectively,  from <kbd><i>groupname</i>.diff2</kbd> and <kbd><i>groupname</i>.<i>cosname</i>.kbprog</kbd> by default, but these defaults may be changed by using the appropriate options (see below). Here <kbd><i>cosname</i></kbd> is derived from <tt><i>subsuffix</i></tt> by substituting the string <kbd>cos</kbd> for <kbd>sub</kbd> as described in Chapter "Subgroup and Coset Files".</p>
<p><tt>automata</tt> and <tt>autcos</tt> will normally attempt to create the subgroup word-acceptor as the last thing they do. However, if you forgot to first find the automatic structure for the group itself, this stage is skipped, or you may have used an option to prevent this acceptor from being computed, so it is sometimes useful to be able to do this separately. It is also sometimes possible to create a subgroup word-acceptor even when MAF could not find an automatic coset structure, and in these circumstances also you will need to run <tt>gpsubwa</tt> separately.</p>

<h3><a name="gptcenum"></a><tt>gptcenum</tt></h3>
<p><kbd>gptcenum <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>]  [-table] [-wa] [-rs] [-pres] [-work_space n] [-max_cosets n][-strategy str] [-compression_mode n] [-max_hole_percentage n] [-allow_holes n] [-as_is | -cr_mode n] [-ep_mode n] [-queued_definitions n] [-<i>groupname</i> [<a href="standard_options.html#coset_systems">-cos</a>] <i>subsuffix</i>]]</kbd></p>
<p><tt>gptcenum</tt> attempts to enumerate the cosets of either the trivial subgroup, if <kbd>-cos</kbd> is not specified, or the subgroup specified in <i>groupname.subsuffix</i>, in <i>groupname</i>. <i>groupname</i> must be the rewriting system for a group otherwise <tt>gptcenum</tt> will produce meaningless results. If the computation is successful the index of the subgroup is reported.</p>
<p>If the <kbd>-table</kbd> option is specified the standardised coset table is output. This automaton is identical to the automaton computed by <tt>gpcosets</tt>. Unlike <tt>automata</tt>, which always outputs the automata it computes, <tt>gptcenum</tt> allows for all the results of its computations to be discarded, except for the index of the subgroup,  (or the size of the group if you are not using a coset system). If the <kbd>-wa</kbd> option is specified <tt>gptcenum</tt> computes the word-acceptor (or coset word-acceptor if this is a coset system). 
</p>
<p>When the <kbd>-cos</kbd> option is specified, then if the <kbd>-rs</kbd> option is specified <tt>gptcenum</tt> uses the Reidemeister-Schreier algorithm to compute a presentation of the subgroup. This will usually be highly redundant, and will typically have many more generators than a presentation computed from an automatic structure, (even one using Schreier generators). You can use <a href="#simplify"><tt>simplify</tt></a> to improve the presentation. The presentation will be output, to <tt><i>groupname</i>.<i>subsuffix</i>.rws</tt>, as a new input file, unless you use the <kbd>-pres</kbd> option, in which case it is output as GAP source code to <tt><i>groupname</i>.<i>subsuffix</i>.pres</tt>, in the same way as subgroup presentations generated by <tt>autcos</tt> with <kbd>-p</kbd>.</p>
<p>Both the <kbd>-wa</kbd> and <kbd>-rs</kbd> options require a coset table, so you are recommended to use the <kbd>-table</kbd> option in both these cases. The coset table provides probably the fastest means of word reduction available in MAF, because the reduction is always done in a single step, so there is a minimal amount of rewriting and no back-tracking at all.</p>
<p><kbd>-work_space n</kbd>  sets the maximum size of the coset table in bytes. For example <kbd>-work_space 1G</kbd> will allow a coset table to use up to 1 Gigabyte of memory. The amount of memory used for other purposes by the program is typically rather small, so usually you could specify an option that was close to the amount of RAM available, or even a little more than this (on the author's computer <tt>gptcenum</tt> performs quite well even when the coset table is allowed to be 50% larger than the amount of RAM actually present). If the value you specify is too large the program will be slowed down because of excessive page faulting. Instead of using <kbd>-work_space n</kbd> you can specify <kbd>-max_cosets n</kbd>, which specifies the maximum number of rows in the table. In that case the amount of memory needed will be this number+1 multiplied by the number of monoid generators multiplied by the amount of memory needed to store an integer, which is 4 bytes, whether you are using the 32-bit or the 64-bit version of MAF, unless you use a 64-bit version of MAF which has enabled support for automata with more than 2^31 states, in which case it is 8 bytes. (A computer needs at least 50GB of RAM to be able to build the smallest possible coset table of this type). If you do do not specify either of these options <tt>gptcenum</tt> will grow the coset table dynamically. This is likely to cause page-faulting sooner than if you had specified a maximum coset table size, because the operating system will be forced to reallocate huge blocks of memory. You should note that easy enumerations will completely more quickly if the maximum coset table size is set to a small value. Even though it has no effect on the amount of work done by the program setting the table to a large size will make it run markedly more slowly because the CPU cache is used less effectively. So if you wanted to enumerate a large number of similar input files it would make sense to set a low limit on the table size in the hope that most enumerations would succeed with this size. Then you could try the ones that failed with a larger table size. Overall this might well be quicker than doing all the enumerations using the larger table size for all of them.</p>
<p><kbd>-strategy string</kbd> sets the strategy. This is a complex and powerful option. It can contain the name of a predefined strategy: <kbd>sims:1</kbd>, <kbd>sims:2</kbd>,... <kbd>sims:10</kbd>, <kbd>fel:0</kbd>, <kbd>fel:1</kbd>, <kbd>easy</kbd>, <kbd>hlt</kbd>, <kbd>hard</kbd>, <kbd>long</kbd>, <kbd>lucky</kbd>,
<kbd>pure_c</kbd>, <kbd>def</kbd>, or <kbd>default</kbd> (the last 2 are not the same). Alternatively you can specify a custom strategy with up to 8 phases. The first 10 of these, the various <kbd>sims:<i>n</i></kbd> strategies exactly match the ten coset enumeration strategies implemented by Charles Sims's TEN_CE coset enumerator in Chapter 5 of <a href="bib.html#Sims94">[Sims94]</a>, (which is not quite what the corresponding strategies in ACE do. Also ACE only supports the odd numbered Sims strategies). Most of the others, apart from "long", "lucky" and "default" try to match the corresponding strategy in ACE. However, strategies that use short-gap filling will not behave quite like their ACE counterparts, because MAF does this in a slightly different way to ACE. In fact no attempt has been made to duplicate ACE's behaviour exactly: the complexity of the ACE source code would make this very difficult to achieve. </p>
<p>The "default" strategy is used if no strategy option is specified. This will do an HLT+look-ahead enumeration until the table overflows, and then alternates three phases in different styles, to mix "HLT" style processing and "Felsch" style processing. The <kbd>-strategy def</kbd> option does something similar, but the mix is slightly different and is intended to match the corresponding ACE strategy. In fact neither of these strategies work as well as they might, because the initial HLT+look-ahead phase will often leave the coset table so full that the other phases do not have much opportunity to do anything before the enumeration fails.</p>
<p>As its name may suggest the <kbd>"long"</kbd> strategy is suited to input files where some of either the relators, or the subgroup generators, are long words. This strategy is mostly Felsch style, but one relator is possibly applied  HLT style to some position (anywhere in the table), with each relator having a roughly equal chance of being selected, each time a row is filled. MAF attempts to apply the relator in the "best"  position, where this means a position requiring the smallest possible number of new definitions. In fact, the code that does this is <em>intentionally</em> not quite correct, and sometimes no relator will be applied, because the gaps will have closed already where MAF chooses to apply the relator. Experiments indicated that this strategy behaved better like this than if MAF goes to the trouble of noticing when this has happened and then picking a different relator and position to apply. This strategy is different from anything ACE can do. The author's intention was to try to match what a human might do when performing an enumeration by hand. It is not always the optimal strategy, but it has outstandingly good behaviour on many input files. For example it can handle the <tt>degen4b</tt> presentation within a few seconds (though not <tt>degen4c</tt>). The author found several input files where this strategy succeeded when all the other predefined strategies failed. The lucky strategy is similar but there is a small amount of pseudo-random variation.</p>
<p>For custom strategies each phase's descriptor start with /. Unlike all other command line options in MAF, the flags that set the strategy are mostly case insensitive. The strategy for a phase is set as follows:</p>
<p><kbd>*</kbd> marks the phase which is returned to when all phases have been executed. (Usually this would probably be the second phase).</p>
<p><kbd>H</kbd> denotes an HLT type phase, <kbd>M</kbd> denotes a CHLT phase (the "mendelsohn:1" option in ACE terminology), G,N partial CHLT phases (only useful for normal closure coset systems). G causes the cyclic conjugates of the relators to be applied, N causes the cyclic conjugates of the subgroup generators to be
applied. (When <tt>gptcenum</tt> processes a normal closure coset system the subgroup generators are effectively extra relators).</p>
<p>If none of H,M,G,N are specified the phase is "Felsch" type.</p>
<p><kbd>2</kbd> or <kbd>3</kbd> select alternate orderings of the conjugated relators for CHLT type phases.</p>
<p><kbd>C</kbd> enables the deduction stack for HLT/CHLT type phases (like Sims:3/Sims:4 or Sims:7/Sims:8).</p>
<p><kbd>L</kbd> enables "look-ahead" for HLT type phases.</p>
<p><kbd>P</kbd> causes an HLT type row to be filled before relators are applied (rather than after).
<p><kbd>S</kbd> enables short gap filling, <kbd>Q</kbd> enables queued short gap filling.
<p><kbd>U</kbd> limits short gap filling using the fill factor (on its own it implies the <kbd>S</kbd> option as well)</p>
<p><kbd>R</kbd> limits short gap filling by requiring the scan to pass through a "low" row (one that is already filled), and also implies the <kbd>S</kbd> option.</p>
<p>Valid combinations of the various short gap options are /S, /Q, /R, /QR, /U, /QU, /UR, /QUR. The S option turns off R,U and Q. The Q option turns off R and U.</p>
<p><kbd>X</kbd> enables "long" gap filling, and completes at most one scan per iteration,in a most nearly complete position; relators are considered round-robin fashion.</p>
<p><kbd>A</kbd> selects ACE definition order (back filled).</p>
<p><kbd>B</kbd> selects MAF definition order (balanced filling). This means that when MAF is either applying a relator to a coset HLT style, or filling a short gap, the next coset to be defined will be attached to the one nearest the beginning of the table. That means that when a relator is applied HLT style cosets will alternately be defined from the front and the back of the relator.</p>
<p><kbd>T</kbd> selects "traditional" definition order (forward filled).</p>
<p>The definition order options  have a usually minor impact on both the number of cosets defined in the course of an enumeration, and the maximum number of live cosets. For a particular input file any one of them may give the best results
<p><kbd>V</kbd> means that some aspects of the phase are randomly changed. The options that can change are the definition order, the style of short gap filling, and the order of CHLT style processing, if this is selected.</p>
<p><kbd>W</kbd> means that the phase uses a randomly chosen style</p>
<p><kbd>:</kbd> introduces the "duration" part of the phase. This consists of a number,
followed by a <kbd>D</kbd> (duration measured by number of cosets defined), or <kbd>R</kbd> (duration measured by number of rows processed). If the number is -1 then the phase lasts for ever, or, if look-ahead is enabled and there are more phases, until a look-ahead is performed.</p>
<p>One can also combine these options with predefined strategies: for example, <kbd>-strategy sims:1/a</kbd> would make modify the <kbd>sims:1</kbd> strategy to behave as it would in ACE. (By default the various "sims" strategies exactly match Sims' book.). The a, t, and b strategy descriptor options are particularly useful in this case. For instance the "long" strategy is equivalent to <kbd>-strategy /bxq</kbd>. Experiments indicate that <kbd>-strategy /axq</kbd> or <kbd>-strategy /txq</kbd> often work a little better, and this is what you get if you use <kbd>-strategy long/a</kbd> or <kbd>-strategy long/t</kbd>. If you do this you need to be aware that some predefined strategies have more than one phase. For example, to modify the fel:1 strategy to use MAF definition order you would need to specify <kbd>-strategy fel:1//b</kbd> because otherwise you would only be setting the definition order on a phase which applies the relators to the identity coset. However, these modifiers work well on the first 8 Sims strategies (which use traditional definition order by default), on "easy" and "hlt" (which use ACE definition order), and "long" and "lucky" (which use MAF definition order). The definition order makes no difference unless either relators are applied to cosets or short gaps are being filled.</p>

<p>In theory "long" and "lucky" might not be correct coset enumeration strategies, because it is possible that the enumerator would spend all its time filling short gaps, and so never fill rows from the beginning of the table. In practice this never seems to happen. The MAF enumerator is different from ACE in this respect. ACE is capable of going wrong with this kind of strategy when there are relators of length 3 (for example with the Fibonacci groups). MAF will not go wrong in that case, because it completely excludes relators of length 3 from gap filling. However, if you want to play safe you can add the 'R' descriptor as a modifier, (for example, <kbd>-strategy long/r</kbd>. It would also be possible to add the 'U' modifier, but this tends not to work well with strategies that use "long" gap filling unless you set a high fill factor. However, enumerations that would have succeeded without either of these restrictions on gap filling will quite often fail with them if the input file is difficult.</p>
<p>Another example: <kbd>-strategy /mcpb:1r/bsx</kbd>. All cyclic conjugates of the relators are applied to a pre-filled row 1 using balanced scans with a deduction stack. Then an unlimited Felsch phase is run which does unlimited immediate short-gap filling, and applies one relator per filled row in round-robin fashion.</p>
<p><kbd>-fill_factor n</kbd> sets the fill-factor used by <kbd>U</kbd> limited short gap filling. The higher the value set the more gaps will be filled. The value 0 is handled as in ACE, and is probably the best value to use, unless you are using a strategy that does "long" gap filling, where it may well be necessary to set a very high value.</p>
<p><kbd>-queued_definitions n</kbd> sets the size of the queue for Q type short gap filling. If this is set to 0 then the strategies that use queued short gap filling do immediate gap filling instead. If it is set to -1 then all short gap filling is disabled completely.</p>
<p><kbd>-cr_mode <i>n</i></kbd> or <kbd>-as_is</kbd> specify how the input file is pre-processed. Specify <kbd>-cr_mode 0</kbd> or <kbd>-as_is</kbd> to use the presentation as is. Specify <kbd>-cr_mode 1</kbd> to use cyclically and freely reduced relators, where the conjugate picked is the first in the reduction ordering. Specify <kbd>-cr_mode 2</kbd> to similarly reduce relators, but this time picking the conjugate which gives the best equation when right-balanced. You might expect that do be the same as <kbd>-cr_mode 1</kbd> but usually it is not, unless all the relators have odd length.</p>
<p><kbd>-ep_mode <i>n</i></kbd>, where 0 &le; <kbd><i>n</i></kbd> &le; 5, selects further processing of the relators as follows:</p>
<ul><li>0=no further processing,
<li>1=conjugated to give fewest cosets when applied to coset 1
<li>2=conjugated to give most cosets when applied to coset 1.
<li>3,4,5 are similar to 0,1,2, but the relators are applied in the reverse of the usual order.</li>
</ul>
<p>Experiments indicate that while one might expect <kbd>-cr_mode 2 -ep_mode 1</kbd> to have the best behaviour this is by no means always the case. Quite often it seems to be the case that if you do this the maximum number of live cosets is as small as possible (which is good, because it means a difficult enumeration has more chance to complete), but the total number of cosets ever defined is more than it would be with some other equivalent presentation, which means that the enumeration takes longer.</p>
<p>In future more options of this type might be added. For example it is plausible that picking the set of conjugates which gave the smallest number of cosets after applying relators to the cosets corresponding to each generator as well as coset 1 would be a better choice than just applying cosets to coset 1.</p>
<p><kbd>-compression_mode n</kbd>  where 0 &le; <kbd><i>n</i></kbd> &le; 3 determines what happens to the "deduction stack" if the table is compressed mid-enumeration.</p>
<ul><li><kbd>-compression_mode 0</kbd> : discard deduction stack</li>
<li><kbd>-compression_mode 1</kbd> : preserve stack renumbering as need be. This may leave duplicate entries if there has been a significant collapse.
<li>modes 2,3 rebuild by column or row, removing duplicates.</li>
</ul>
<p>In any case the enumerator tries to avoid invoking compression when the deduction stack is not empty, and may discard the deduction stack if it believes it would be faster to scan the entire table with an HLT "look-ahead".</p>
<p><kbd>-max_hole_percentage n</kbd> : selects maximum percentage of holes. If this is set to 100, compression will be disabled completely. MAF sets this to 30%, whereas with ACE most strategies set it to 10%. MAF computes this as a percentage of the maximum table size, not the current size. The idea is to compress the table as seldom as possible, because compressing the table is a waste of time (except that it may marginally improve the effectiveness of CPU RAM caching).
<p><kbd>-allow_holes n</kbd> sets a number of holes which will be tolerated if the enumeration is about to fail due to lack of space, or the table is going to be resized. Setting this to a high value will prevent fruitless "look-aheads" when HLT+Lookahead mode is used. The default value is 10000. If you are going to have a very large coset table size, then it might be best to set this to a higher value.</p>
<p><kbd>-build_standardised</kbd> causes the table to be built in BFS order, so that it is "standardised". This means that as rows are filled some rows may be interchanged with rows defined earlier. If one consults Sims, one sees that doing this is often quite beneficial, but that when it is not beneficial it can have an extremely bad effect. For some input files using this option will increase the amount of time and memory needed for the enumeration to complete exponentially. The author does not recommend the use of this option.</p>
<h4>Word-ordering</h4>
<p>The word-ordering method will affect some coset enumeration strategies, because the order in which relators are applied to cosets will be affected by the ordering of the relators in the reduction order. If a coset table is created <tt>gptcenum</tt> labels it correctly for the chosen word-ordering. You should note that this is a very simple computation when the word-ordering is <code>"shortlex"</code>, but considerably more complex for orderings such as recursive. In future <tt>gptcenum</tt> will probably have an option to produce the confluent rewriting system that can also be deduced from the structure of the completed coset table.</p>
<h4><tt>gptcenum</tt> and <tt>automata</tt> compared</h4>
<p>The author implemented <tt>gptcenum</tt> to see if he could gain any insight from coset enumeration that would help him to improve his Knuth-Bendix implementation, and to see to what extent, if any, the oft repeated claim that coset enumeration is better than Knuth-Bendix is really justified. As yet he has not come to any firm conclusions, nor applied any lessons learned. The author is satisfied, that for the great majority of input files, <kbd>automata -nowd</kbd> will perform acceptably when compared with <tt>gptcenum</tt>, only a little more slowly on average, and that for difficult presentations it is usually superior to <tt>gptcenum</tt>. However, for easy presentations, for which HLT style enumeration succeeds quickly <tt>gptcenum</tt> with that strategy will probably run at least 50% faster than <tt>automata</tt>. For some presentations <tt>gptcenum</tt> requires only about 30% of the time that <tt>automata</tt> requires. It is also interesting to compare memory usage. Both programs construct rather similar data structures. In both there are rows of transitions which have as many columns as there are monoid generators, and these take up the same amount of memory in each program. But <tt>automata</tt> stores 32 bytes of information for every node in its table (or 40 bytes in the 64-bit version), which means that for the typical 2-generator group where the table has either 3 or 4 columns) <tt>automata</tt> requires significantly more memory. Also <tt>automata</tt> keeps this amount of information both at L0 nodes, which correspond to rows in a coset table, but also at L1 and  some L2 nodes, which do not appear in a coset table at all. On the other hand <tt>automata</tt>'s index automaton rarely needs to create L0 nodes for every coset. If a wreath product word-ordering is being used the total number of nodes may be minute compared with the group's order. Also, for difficult presentations, <tt>automata</tt> will typically collapse far sooner than <tt>gptcenum</tt>. For example, for the 6561#8 presentation Derek Holt's "Handbook of computational group theory" remarks that more than 30,000,0000 cosets are needed to perform a Felsch style enumeration and 100,000,000 for an HLT style enumeration. The author is not able to reproduce these results. The best predefined strategy for the presentation he uses for  this  group seems to be "hard" which completes with under 21 million cosets. The "long" strategy needs around 45 million, fel:1 around 50 million, and none of the other strategies tried worked with 60 million cosets. The fastest enumeration required 66 seconds. Yet <tt>automata</tt> proves this group has order 6561 using only a maximum of around 70,000 L0 nodes, on the same PC in atound 30 seconds. </p>
<h3><a name="gpvital"></a><tt>gpvital</tt></h3>
<p><kbd>gpvital <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [-axioms] [-raw | -kb] [-diff2c] groupname [<a href="standard_options.html#coset_systems">-cos</a> [<i>subsuffix</i>]]</kbd></p>
<p><tt>gpvital</tt> calculates a new presentation for a group whose automatic structure has already been computed. The presentation is usually based on the correct primary word-difference machine (the .diff1c automaton), and is in some sense a canonical presentation for the particular generating set and word-ordering method used in the rewriting system. In principle there is an axiom which proves the necessity of each transition in this word-difference machine. However, MAF will usually simplify the new presentation somewhat by eliminating axioms that are obvious consequences of earlier ones. This simplification can be prevented by use of the <kbd>-raw</kbd> option, or you can ask MAF to make a more determined effort to eliminate unnecessary axioms by using the <kbd>-kb</kbd> option.</p>
<p> The <kbd>-axioms</kbd> option will cause the original axiom set to be included first. This option may be of interest when you have finally succeeded in finding the automatic structure for a highly pathological group presentation: any extra axioms in the new presentation will normally be equations that are very hard to prove using the original axiom set, and the automatic structure will usually be much easier to compute using the new presentation.</p>


<h3><tt>gpsubwa</tt></h3>
<p><kbd>gpsubwa <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>format</i>] <a href="standard_options.html#reduction_method">[reduction_method]</a> <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>gpsubwa</tt> attempts to compute a subgroup word-acceptor for the subgroup <i>H</i> of the automatic group <i>G</i> (whose automatic structure must previously have been computed), where the rewriting system for <i>G</i> is defined in <kbd><i>groupname</i></kbd>, and the generators for <i>H</i> are defined in the file, <kbd><i>groupname</i>.<i>subsuffix</i></kbd>, where <kbd><i>subsuffix</i></kbd> defaults to <kbd>sub</kbd>. See <a href="substructure_files.html">Substructure files</a> for information on the format of the latter file.) The computed automaton is output to the file <kbd><i>groupname</i>.<i>subsuffix</i>.wa</kbd>.</p>
<p><kbd>gpsubwa</kbd> requires the word-acceptor and general multiplier for an automatic structure of <i>G</i>, which it inputs from the files <kbd><i>groupname</i>.wa</kbd> and <kbd><i>groupname</i>.gm</kbd>.  These need to be computed first by running <tt>automata</tt> or its constituents. It also requires word-reduction automata for <i>G</i> and for cosets of <i>H</i> in <i>G</i>, as described above. These are input, respectively,  from <kbd><i>groupname</i>.diff2</kbd> and <kbd><i>groupname</i>.<i>cosname</i>.kbprog</kbd> by default, but these defaults may be changed by using the appropriate options (see below). Here <kbd><i>cosname</i></kbd> is derived from <tt><i>subsuffix</i></tt> by substituting the string <kbd>cos</kbd> for <kbd>sub</kbd> as described in Chapter "Subgroup and Coset Files".</p>
<p><tt>automata</tt> and <tt>autcos</tt> will normally attempt to create the subgroup word-acceptor as the last thing they do. However, if you forgot to first find the automatic structure for the group itself, this stage is skipped, or you may have used an option to prevent this acceptor from being computed, so it is sometimes useful to be able to do this separately. It is also sometimes possible to create a subgroup word-acceptor even when MAF could not find an automatic coset structure, and in these circumstances also you will need to run <tt>gpsubwa</tt> separately.</p>



<h3><a name="gpwa"></a><tt>gpwa</tt></h3>
<p><kbd>gpwa <a href="standard_options.html#loglevel">[loglevel]</a> [format] [<a href="standard_options.html#coset_systems">-cos</a>] [<i>dm_selector</i>] [options] <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>gpwa</tt> computes the word-acceptor for a difference machine. There is an option to calculate an "outer geodesic" acceptor. This is an acceptor which rejects all the words which are definitely not geodesic, and accepts all the others. So its language definitely includes all the geodesic words, but probably includes some words that are not geodesic. If a shortlex automatic structure exists then this acceptor always exists, whereas the true geodesic acceptor may not. So it could be useful if you are interested in enumerating geodesic words.</p>
<p><i>dm_selector</i> can be one of: <kbd>-diff2c</kbd>,<kbd>-diff1c</kbd>,<kbd>-diff2</kbd>,<kbd>-pdiff2</kbd>,<kbd>-pdiff1</kbd>. Several of these word-difference machines are only available if the automatic structure has been constructed already; it is sometimes interesting to compare how quickly the word-acceptor can be built from each of the word-difference machines.</p>
<p>You can use this program to build a provisional word-acceptor for a group or coset system for which <tt>automata</tt> was unsuccessful.</p>
<p>The following special options are accepted:</p>
<p>If the <kbd>-outer_geodesic</kbd> option is specified <tt>gpwa</tt> constructs an FSA which accepts all words
that cannot be reduced to a shorter word by the word difference machine. This option only makes sense if the word-ordering for the rewriting system is geodesic. Note that the FSA built in this case will usually also accept some words that can in fact be reduced to a shorter word.</p>
<p>If the <kbd>-max_length n</kbd> option is specified, where n is a positive integer, then when the FSA is being constructed, new states are only created if the defining word has length at most n, so that the output FSA will only reject words which can be reduced with a rule with a LHS word of length n or below.
</p>
<p>If the <kbd>-max_states n</kbd> option is specified, then prior to minimisation the FSA constructed is allowed to have at most n states. This has a similar effect to <kbd>-max_length k</kbd> for some k, but usually some rules of length k+1 would reject words.</p>
<p>Both the <kbd>-max_length n</kbd> and the <kbd>-max_states n</kbd> option are to allow an FSA to be built when the build process would otherwise fail due to time or space constraints.</p>

<h3><a name="gpxlatwa"></a><tt>gpxlatwa</tt></h3>
<p><kbd>gpxlatwa <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>gpxlatwa</tt> computes a unique word-acceptor for a group using a new set of generators, which are specified as subgroup generators in <tt><i>groupname</i>.<i>subsuffix</i></tt> (or <tt><i>groupname</i>.sub</tt> if <kbd><i>subsuffix</i></kbd> is not specified). The subgroup must have index 1, and the substructure file must specify names and inverses for the subgroup generators. The word-acceptor <tt><i>groupname</i>.wa</tt> must previously have been computed, as must the MIDFA coset general multiplier <tt><i>groupname</i>.<i>cosssuffix</i>.migm</tt>.  The new word-acceptor is output to the file <tt><i>groupname</i>.<i>subsuffix</i>.xwa</tt>. <tt>gpxlatwa</tt> works by first computing words in the new generators for each of the old generators. Then it computes the FSA which accepts words if and only if it is a word formed by translating a word which was accepted by the original acceptor using these words to map from the original generators to the new generators. Then
it modifies the FSA so that each accepted word is replaced by its free reduction.</p>
<p>For example, suppose the original set of generators is <code>[a,A,b,B,c,C]</code> and that <code>[c,a*a*b*A*A*B]</code> is one of the axioms, so that the group is also generated by <code>[a,A,b,B]</code>. Furthermore, suppose that <code>c*b</code> is an accepted word in the original generators. The direct translation into the new generators would be <code>a*a*b*A*A*B*b</code>, therefore the new acceptor will accept the word a*a*b*A*A for the corresponding group element.
<h3><a name="isconjugate"></a><tt>isconjugate</tt></h3>
<p><kbd>isconjugate <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [<i>reduction_method</i>] <i>groupname</i> <i>word1</i> [<i>word2</i>]</kbd></p>
<p><tt>isconjugate</tt> can be used to attempt to determine either whether two words are conjugates (if two words are specified on the command line), or the set of words that are conjugate to the given word (if only one word is specified). If requires that <tt>automata</tt> or a similar program has computed an automaton that allows word-reduction to take place.</p>
<p> When two words are specified <tt>isconjugate</tt> will attempt to find the conjugacy class of each word, and stop if it finds that these have a common element, at which point it can compute an element <i>u</i> such that <i>word1^u=u^-1*word1*u = word2</i>. The return value is 0 if a conjugating element is found, or 2 if the group is finite and there is no such element, or the group is infinite but either word1 or word2 have only finitely many conjugates and are not conjugate to each other. In the case where both conjugacy classes are infinite and different <tt>isconjugate</tt> will run until it runs out of memory and crashes or it tries to create a word that is longer than the maximum word length allowed. <tt>isconjugate</tt> is very simple-minded, and there might be much better ways to discover whether two elements could possibly be conjugates: for example by checking if the elements had different orders using <tt>gporder</tt>. <tt>isconjugate</tt> will allow you to process coset systems using the usual <kbd>-cos <i>subsuffix</i></kbd> syntax, though the author is not sure why you would ever want to do this. In this case the two words will be considered to be conjugate if there is some word <i>u</i> such that <i>u^-1*word*u</i> and <i>word2</i> are in the same coset.</p>
<p>If only one word is specified <tt>isconjugate</tt> will only stop if the word has finitely many conjugates, at which point it will output a list containing all of them.</p>

<h3><a name="isnormal"></a><tt>isnormal</tt></h3>
<p><kbd>isnormal <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p>Assuming <tt>automata</tt> or a similar program has computed an automaton that allows coset word-reduction to take place, <tt>isnormal</tt> will tell you whether the specified subgroup is normal. If is not, then it will list a subgroup generator and a group generator that shows this.</p>
<p><tt>isnormal</tt> will not against a normal closure coset system.</p>

<h3><a name="makecosfile"></a><tt>makecosfile</tt></h3>
<p><kbd>makecosfile [-sg] [-ni] <i>groupname</i> [<i>subsuffix</i>]</kbd></p>
<p><tt>makecosfile</tt> can be used to generate a coset system from an input file and a substructure file. Usually is done automatically when you use <tt>automata</tt> or one of the KBMAG compatibility programs to process a coset system. However you can use <tt>makecosfile</tt> to generate the coset system without processing it as an input file. You can do that if you want to edit the coset system manually, or create it a non-standard way. In that case you will need to invoke other utilities with the name of the coset system itself, rather than use the <kbd>-cos</kbd> option, otherwise the coset system would be regenerated.</p>
<p><tt>makecosfile</tt>   takes its input from the input file <kbd><i>groupname</i></kbd>, which should contain a declaration of a record defining a rewriting system, in the format described in <a href="input_files.html">Input files</a>, and from a substructure file <kbd><i>groupname</i>.<i>subsuffix</i></kbd>, which should contain a list of subgroup generators and (optionally) names for them, in one of the three formats described in <a href="#SubstructureFiles">Substructure Files</a>. The input file should use one of the following orderings:
"shortlex"; "wreathprod"; "rt_wreathprod"; "rt_recursive".  <tt>makecosfile</tt> generates the coset system corresponding to the two input files. Output is to the file <kbd><i>groupname</i>.<i>cossuffix</i></kbd>, and is a coset system, the contents of which will be described in the next paragraph. How <kbd><i>cossuffix</i></kbd> is determined is explained in <a href="coset_system_names.html">Coset system filenames</a>.
</p>
<p>If the option <kbd>-sg</kbd> is not specified, then the generated coset system will either be a <a href="cosets.html#simple">simple coset system</a>, or <a href="cosets.html#normal">a normal closure coset system</a>. This will be the case even if the subgroup generators are named in the substructure file.</p>
<p>If the option <kbd>-sg</kbd> (for "subgroup generators") is specified, then the record defined in the substructure file must contain a <kbd>subGeneratorNames</kbd> field. The coset system will then be generated as <a href="cosets.html#named">a coset system with named subgroup generators</a>. <p>By default, if the substructure file does not contain a <kbd>subGeneratorInverseNames</kbd> field, then inverses of the <i>H</i>-generators will be appended as further <i>H</i>-generators. (The inverse symbol for <i>H</i>-generator <i>x</i> is named <i>x^-1</i>.) If the <kbd>-ni</kbd> option is specified, however, then these inverse generators are not introduced. (This option is provided because KBMAG has it: it is not clear to the author of MAF why this would ever be useful, because it is much more difficult for MAF to analyse such a coset system since it is no longer possible to use balancing to move <i>H</i>-generators on the LHS of equations to the RHS.</p>

<h3><a name="reduce"></a><tt>reduce</tt></h3>
<kbd>reduce <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [-steps] <a href="standard_options.html#reduction_method">[reduction_method]</a> <i>rwsname</i> [-i | -read filename | word] [output_file]</kbd><br>
<p>This program can be used to reduce words to their normal form in the ordering specified in file <kbd><i>rwsname</i></kbd>. It is assumed that <tt>automata</tt> has previously run, and that it has output at least one FSA which makes at least provisional word reduction possible. If not, or if you specify that <kbd>reduce</kbd> should use an automaton that is not available,  then <kbd>reduce</kbd> will exit with an error message.</p>
<p><tt>reduce</tt> reduces words using one of the automata produced by <tt>automata</tt>. The reductions will always be correct in the sense that the output word will represent the same element as the input word. If automata has completed successfully, then at least one of the the first five automata in the list of values that can be specified for <kbd><i>reduction_method</i></kbd> will exist, and <tt>reduce</tt> will use this automaton to perform the word reduction. It can therefore be used to solve the word problem in the monoid. If <tt>automata</tt> produced only provisional output, then there will usually be some pairs of words which are really equal as elements, but which reduce to distinct words, and so this program cannot be used to solve the word problem.</p>
<p>If the <kbd>-steps</kbd> option is specified MAF will apply one reduction at a time to the word and output each word.</p>
<p>The KBMAG option <kbd>-mrl <i>maxreducelen</i></kbd> is accepted, but ignored. Throughout MAF, words are limited to a length of MAX_WORD symbols, which currently equals 65533 symbols.</p>
<p> <i>output_file</i> may only be specified if the <kbd>-read filename</kbd> option has been used. If the <kbd>-i</kbd> option is used then the program will display a prompt and allow words to be input interactively. Words must be terminated with a ',' or a ';' when you want to quit the program. On most operating systems it will be necessary to press Enter after the ',' or ';' character.</p>
<p>If the <kbd>-read</kbd> option is specified, then the input file should be a GAP list using the following syntax:</p>
<pre>words := 
[
  word1, word2, ... wordn
];</pre>
<p>Each word should follow the same rules for input as are used in MAF's usual input files.</p>

<h3><a name="simplify"></a><tt>simplify</tt></h3>
<p><kbd>simplify <a href="standard_options.html#loglevel">[<i>loglevel</i>]</a> [-strategy <i>n</i>] [-abelian] [-keep_generators] [-no_simplify] [-kb] [-keep_going] [-long_length <i>n</i>] [-max_elimination <i>n</i>] [-max_seen <i>n</i>] [-raw]
<i>input_file</i> [-overwrite | -o | <i>output_file</i>]</kbd></p>
<p><tt>simplify</tt> is a Tietze transformation program. It is not yet capable of performing all types of Tietze transformation - it can remove redundant generators, but it cannot introduce a new generator. It can reduce the length of a presentation as much as possible, and it can also use Knuth-Bendix methods to try to remove some redundant relators. <tt>simplify</tt> can be used to simplify the ".rws" files generated by <tt>gpsubpres</tt> or <tt>automata</tt>, or indeed any rewriting system in KBMAG/MAF format. <tt>simplify</tt> will happily increase the size of the presentation if it can eliminate generators by doing so, except that it will usually stop if the total length of the axioms has doubled (so running it more than once may eliminate more generators at the cost of increasing the total length of the relators further).</p>
<p><kbd>-strategy n</kbd>, where n is a number from 0 to 15, influences the order in which
generators and axioms are eliminated. 0,1, or 3 is usually best, 4-7 often poor. Even numbered
strategies prefer to eliminate later generators first, odd numbered strategies try to select a generator
to eliminate based on the estimated increase in size of the presentation.</p>
<p><kbd>-keep_generators</kbd> tells <tt>simplify</tt> not to eliminate generators. <kbd>-max_elimination <i>n</i></kbd> limits elimination of generators to relators of length <i>n</i> or below. <kbd>-max_seen <i>n</i></kbd> limits elimination of generators to relators containing at most <i>n</i> distinct
generators but with no limit on the length of the relator.</p>
<p><kbd>-keep_going</kbd> tells simplify to eliminate as many generators as possible, even if
the size of the presentation increases a lot.</p>
<p><kbd>-no_simplify</kbd> tells simplify not to try to eliminate axioms, except when
eliminating an unnecessary generator.</p>
<p><kbd>-abelian</kbd> tells <tt>simplify</tt> to compute the presentation of the abelian quotient
of the presentation. It does this without using linear algebra. This is slow (so that programs like GAP may well be able to do much better), but it does mean that abelianisation can be computed for presentations with very large generating sets for which linear algebra techniques might not be practical.</p>
<p><kbd>-best_equation_relators</kbd> causes <tt>simplify</tt> to keep the cyclic conjugate that gives
the best equation when right balanced. The default is to keep the least
conjugate in the word-ordering. The default usually works better and is faster.</p>
<p><kbd>-raw</kbd> speeds <tt>simplify</tt> up by not filtering the axioms through a new MAF rewriting system at the end.
<p><kbd>-kb</kbd> tells MAF to perform Knuth-Bendix expansion to eliminate more axioms. In
this case <kbd>-long_length n</kbd> limits this options to axioms of length &lt; <i>n</i>. This should only be attempted when the number of generators is less than about 50 as otherwise it is likely to be prohibitively slow.</p>
<p>If not output filename is specified <tt>simplify</tt> creates a new input file called <tt><i>input_file</i>.simplify</tt>, but <kbd>-overwrite</kbd> causes <tt>simplify</tt> to overwrite the original input file instead.</p>
<p>It is often worth running <tt>simplify</tt> more than once. Especially when the relators are long it  sometimes happens that when <tt>simplify</tt> creates the new input file for the group MAF is able to reduce the length of some of the relators further. This happens because MAF usually conjugates all the relators as it is doing so. It might then happen that this new short relator can be used to simplify some of the relators that have already been added. It also sometimes happens that changing the order of the generators can lead to further simplification of the presentation. </p>
<p>It is often the case that after simplification there are some short relators that are redundant. However, eliminating these is usually not a good idea as without them MAF may find the input file harder to process. In particular coset enumeration is liable to be much more difficult, and any subgroup presentations computed from the new input file may be much more difficult to handle.</p>
</body>
</html>
